{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial: uui","text":"<p>This project manages automated communication sequences, similar to marketing campaigns.  A GoAI Campaign acts as a blueprint for outreach, with Campaign Steps defining individual actions like emails or calls.  Engage Sequences automate these communications, enrolling contacts and sending messages according to Sequence Steps.  The system tracks interactions as Sequence Events and stores message content as Sequence Step Content.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"GoAI Campaign\"]\n    A1[\"GoAI Campaign Step\"]\n    A2[\"GoAI Campaign Message\"]\n    A3[\"Engage Sequence\"]\n    A4[\"Engage Sequence Step\"]\n    A5[\"Engage Sequence Membership\"]\n    A6[\"Engage Sequence Event\"]\n    A7[\"Engage Sequence Step Content\"]\n    A8[\"Engage Sequence OAuth Credential\"]\n    A0 -- \"Has many\" --&gt; A1\n    A0 -- \"Has many\" --&gt; A2\n    A1 -- \"Belongs to\" --&gt; A0\n    A3 -- \"Has many\" --&gt; A4\n    A3 -- \"Has many\" --&gt; A5\n    A3 -- \"Has many\" --&gt; A8\n    A4 -- \"Belongs to\" --&gt; A3\n    A4 -- \"Has many\" --&gt; A7\n    A5 -- \"Belongs to\" --&gt; A3\n    A5 -- \"Has current\" --&gt; A4\n    A5 -- \"Has many\" --&gt; A6\n    A6 -- \"Belongs to\" --&gt; A5\n    A7 -- \"Belongs to\" --&gt; A4\n    A8 -- \"Belongs to\" --&gt; A3\n    A4 -- \"Has many\" --&gt; A6\n</code></pre>"},{"location":"#chapters","title":"Chapters","text":"<ol> <li>GoAI Campaign</li> <li>GoAI Campaign Step</li> <li>GoAI Campaign Message</li> <li>Engage Sequence</li> <li>Engage Sequence Step</li> <li>Engage Sequence Step Content</li> <li>Engage Sequence Membership</li> <li>Engage Sequence Event</li> <li>Engage Sequence OAuth Credential</li> </ol> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"01_goai_campaign/","title":"Chapter 1: GoAI Campaign","text":"<p>Imagine you're planning a marketing campaign. You want to reach out to hundreds of potential customers with a personalized message, but doing it manually would take forever.  That's where a GoAI Campaign comes in. Think of it like your marketing campaign blueprint. It defines your overall strategy: who you're targeting, the message you want to convey, and the different steps involved, like sending emails, SMS messages or even making calls.  It's the master plan for reaching out to potential customers efficiently and automatically.</p>"},{"location":"01_goai_campaign/#key-concepts","title":"Key Concepts","text":"<ul> <li>Target Audience: This is the group of people you want to reach. In GoAI, you select a pre-defined audience from your Customer Data Platform (CDP). Think of this like choosing a mailing list.</li> <li>Message:  This is the information you want to share with your audience. It can be anything from a promotional offer to an invitation to a webinar. In GoAI, you can define various messages tailored to different communication channels (e.g., email, SMS, calls).</li> <li>Steps: These are the actions taken during your campaign. A step could be sending an email, making a phone call, or sending a LinkedIn message.  Each step has its own specific message and settings.</li> </ul>"},{"location":"01_goai_campaign/#building-a-simple-goai-campaign","title":"Building a Simple GoAI Campaign","text":"<p>Let's say you want to run a simple email campaign to invite potential customers to a webinar.  Here's how you'd use a GoAI Campaign to do this:</p> <ol> <li> <p>Create a Campaign: First, you'd create a new GoAI Campaign and give it a title like \"Webinar Invitation Campaign.\"</p> </li> <li> <p>Define Your Target Audience: You select your target audience from your CDP. Let's say you choose an audience called \"Potential Leads.\"</p> </li> <li> <p>Add a Step (Email):  You add an email step to your campaign. Within this step, you craft the email message inviting people to the webinar.  </p> </li> </ol> <p><pre><code># Simplified example: Creating a campaign step\ncampaign_step = Goai::CampaignStep.new(type: \"EMAIL\", prompt: \"Join our webinar!\")\n</code></pre>    This creates a new campaign step of type \"EMAIL\" with the prompt \"Join our webinar!\". The prompt serves as the basis for generating the email content. You'll learn more about GoAI Campaign Steps in the next chapter.</p> <ol> <li>Generate and Send Messages: GoAI will then use your campaign settings and selected audience data to generate personalized email messages for each person in your target audience. These messages are then sent automatically.</li> </ol>"},{"location":"01_goai_campaign/#under-the-hood","title":"Under the Hood","text":"<p>When you launch a GoAI Campaign, here's a simplified look at what happens behind the scenes:</p> <pre><code>sequenceDiagram\n    participant User\n    participant GoAI Campaign\n    participant CDP\n    participant Go Engage\n    User-&gt;&gt;GoAI Campaign: Start Campaign\n    GoAI Campaign-&gt;&gt;CDP: Fetch Audience Data\n    CDP--&gt;&gt;GoAI Campaign: Audience Data\n    loop For each contact\n        GoAI Campaign-&gt;&gt;GoAI Campaign: Generate Personalized Message\n        GoAI Campaign-&gt;&gt;Go Engage: Send Message\n        Go Engage--&gt;&gt;GoAI Campaign: Message Sent Confirmation\n    end\n</code></pre> <ol> <li>Fetch Audience Data: The GoAI Campaign retrieves the contact information for each person in your chosen target audience from the CDP.</li> <li>Generate Personalized Message:  For each contact, the campaign uses its message templates and AI to create a personalized message.</li> <li>Send Message:  The personalized message is then sent through the appropriate channel (in this example, email) using Go Engage.</li> </ol>"},{"location":"01_goai_campaign/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Goai::Campaign</code> model (app/models/goai/campaign.rb) is the core of the GoAI Campaign. It handles everything from defining the campaign's settings (like the target audience and campaign type) to managing the campaign steps and generating messages.</p> <pre><code># app/models/goai/campaign.rb (simplified)\nclass Goai::Campaign &lt; ApplicationRecord\n  has_many :campaign_steps # Connects the campaign to its steps\n  # ... other code ...\nend\n</code></pre> <p>The <code>has_many :campaign_steps</code> line establishes the relationship between a campaign and its individual steps.  You'll learn more about steps in the next chapter.</p>"},{"location":"01_goai_campaign/#conclusion","title":"Conclusion","text":"<p>In this chapter, you learned about the GoAI Campaign \u2013 your blueprint for automated, personalized marketing campaigns. We covered the key concepts and walked through a simple example of creating an email campaign.  In the next chapter, we'll dive deeper into the GoAI Campaign Steps that make up your campaign's actions.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"01_messenger/","title":"Chapter 1: Messenger","text":"<p>Let's imagine you want to add a live chat widget to your website so your customers can easily contact you.  The <code>Messenger</code> component in <code>uui</code> is the tool that makes this happen! It's the main UI component that displays the chat window on your webpage. It takes care of everything the user sees and interacts with, like showing messages and sending them to your server.  Think of the <code>Messenger</code> as the storefront of your chat application.</p>"},{"location":"01_messenger/#embedding-the-messenger","title":"Embedding the Messenger","text":"<p>To get started, you need to add the <code>Messenger</code> to your webpage. It's like building the storefront of your chat shop.  We do this by adding a bit of Javascript code.</p> <p>Here's a simplified version of how it works:</p> <pre><code>// app/javascript/embed.js\nimport ChaskiqMessengerEncrypted from '@chaskiq/messenger/src/client_messenger/messengerEncrypted';\n\nwindow.ChaskiqMessengerEncrypted = ChaskiqMessengerEncrypted;\n</code></pre> <p>This code imports the <code>ChaskiqMessengerEncrypted</code> component and makes it available to your webpage's Javascript. This is like bringing in the blueprints for your chat storefront.</p> <p>Next, you\u2019ll initialize the Messenger with some options:</p> <p><pre><code>// app/javascript/new_embed.js (simplified)\nwindow.Chaskiq = { /* ... */ }; // Contains helper functions\n\nwindow.Chaskiq.load = function (options) {\n  this.options = options; // Store the options\n  window.Chaskiq.initPopupWidget(options); // Initialize the widget\n  // ... other initialization logic\n}\n</code></pre> The <code>load</code> function in <code>new_embed.js</code> is responsible for taking your specific settings (like your app ID and domain) and using them to configure the Messenger. <code>initPopupWidget</code> then uses these options to build and display the widget on the page.</p>"},{"location":"01_messenger/#under-the-hood","title":"Under the Hood","text":"<p>When a user visits your webpage, the Javascript code creates a new <code>Messenger</code> instance. This <code>Messenger</code>  handles user interactions, message display, and sending messages back to the server.  Let's see a simplified sequence diagram of how it works when a user sends a message:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n\n    User-&gt;&gt;Browser: Types a message and presses Enter\n    Browser-&gt;&gt;Messenger: Sends the message\n    Messenger-&gt;&gt;Server: Sends the message to the backend\n    Server--&gt;&gt;Messenger: Confirms message received\n    Messenger-&gt;&gt;Browser: Updates the chat window with the message\n    Browser-&gt;&gt;User: Displays the message in the chat window\n</code></pre> <p>The <code>Messenger</code> component interacts with the backend using a combination of techniques.  It uses events to communicate with the parent frame and ultimately make requests to the server.</p> <pre><code>// app/javascript/new_embed.js (simplified)\npushEvent: async function (eventType, data) {\n  // ... Code to send the event to the iframe\n}\n</code></pre> <p>This <code>pushEvent</code> function sends the event and data to the iframe, which is like sending a message to the back of your chat storefront. This is explained in detail in Stimulus Controllers.</p>"},{"location":"01_messenger/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about the <code>Messenger</code> component, the heart of <code>uui</code>'s chat widget.  We saw how to embed it on your webpage and got a peek under the hood to understand how it works.  In the next chapter, we'll explore Conversations, which represent individual chat threads within the Messenger.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"02_conversations/","title":"Chapter 2: Conversations","text":"<p>Continuing from our exploration of the Messenger, which acts as the storefront of our chat application, let's delve into the concept of <code>Conversations</code>.</p> <p>Imagine a busy store with multiple customers interacting with staff. Each individual interaction between a customer and a staff member is like a <code>Conversation</code> in <code>uui</code>.  Conversations help organize and manage these individual chat threads within the Messenger.  They keep track of the message history, which agent is assigned, and the current status of the conversation (e.g., open, closed).</p>"},{"location":"02_conversations/#understanding-conversations","title":"Understanding Conversations","text":"<p>Let's break down the core aspects of a <code>Conversation</code>:</p> <ul> <li>Message History: Just like remembering what was discussed with a customer, the <code>Conversation</code> stores all messages exchanged between the user and the agent.</li> <li>Agent Assignment: This is like assigning a specific staff member to assist a particular customer. In <code>uui</code>, an agent can be assigned to a <code>Conversation</code> to handle it.</li> <li>Conversation Status:  This indicates the current state of the interaction \u2013 is the customer still actively chatting (open) or has the issue been resolved (closed)?  Just like knowing if a customer is still browsing or has left the store.</li> </ul>"},{"location":"02_conversations/#using-conversations","title":"Using Conversations","text":"<p>When a user starts a new chat in the <code>Messenger</code>, a new <code>Conversation</code> is created behind the scenes.  Let\u2019s imagine a user sends the message \"Hello, I need help!\".  </p> <p>This triggers the creation of a new <code>Conversation</code> and adds the message to its history.  This is similar to a new customer walking into the store and starting a conversation.</p> <pre><code>// Simplified example of creating a conversation (backend)\nconst conversation = new Conversation();\nconversation.messages.push(\"Hello, I need help!\");\nconversation.status = \"open\";\nconversation.save();\n</code></pre> <p>This simplified backend code creates a new <code>Conversation</code> object, adds the user's message, marks the status as \"open\", and saves it.  The actual implementation uses more complex logic to handle agent assignment and other details.</p>"},{"location":"02_conversations/#under-the-hood","title":"Under the Hood","text":"<p>Let\u2019s see what happens when a user sends a message in an existing conversation:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n    participant Conversation\n\n    User-&gt;&gt;Browser: Types a message\n    Browser-&gt;&gt;Messenger: Sends the message\n    Messenger-&gt;&gt;Server: Sends the message to the backend\n    Server-&gt;&gt;Conversation: Adds the message to the conversation history\n    Server--&gt;&gt;Messenger: Confirms message received\n    Messenger-&gt;&gt;Browser: Updates the chat window\n    Browser-&gt;&gt;User: Displays the message\n</code></pre> <p>The <code>Conversation</code> is updated on the server-side whenever a new message is sent or the conversation status changes. The <code>Messenger</code> then displays the updated conversation to the user.</p> <p>The following code snippet (heavily simplified) demonstrates how the <code>conversations</code> component retrieves and displays existing conversations within the Messenger:</p> <pre><code>// app/javascript/packages/messenger/src/client_messenger/conversations/conversations.tsx\n// ... other code ...\n\n{conversations.map((o) =&gt; {\n  // ... code to display each conversation ...\n})}\n\n// ... other code ...\n</code></pre> <p>This code snippet shows how the list of <code>conversations</code> is iterated over and displayed in the Messenger's UI.</p>"},{"location":"02_conversations/#conclusion","title":"Conclusion","text":"<p>This chapter introduced the concept of <code>Conversations</code> and their importance in managing individual chat interactions within the Messenger.  We explored the key components of a <code>Conversation</code> and saw how they work together to manage the flow of messages and agent assignments. In the next chapter, we'll learn about AppPackages, which allow you to add interactive elements to your conversations.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"02_goai_campaign_step/","title":"Chapter 2: GoAI Campaign Step","text":"<p>Continuing from our discussion on GoAI Campaigns, let's look at the individual building blocks that make them up: GoAI Campaign Steps.</p> <p>Imagine you\u2019re planning a trip.  Your overall trip is the \"campaign,\" but each part of the journey\u2014like flying to your destination, checking into your hotel, and visiting a museum\u2014are individual \"steps.\"  Similarly, a GoAI Campaign Step is a single action within your automated marketing campaign.</p>"},{"location":"02_goai_campaign_step/#key-concepts","title":"Key Concepts","text":"<p>A GoAI Campaign Step represents a specific interaction with a customer.  Each step can be a different type of communication:</p> <ul> <li>Email: Sending a personalized email message.</li> <li>SMS: Sending a text message.</li> <li>LinkedIn Message: Sending a message through LinkedIn.</li> <li>Call: Making a phone call (either by a human or using AI).</li> </ul> <p>Each step within your GoAI Campaign is executed in a defined order, just like your trip itinerary.</p>"},{"location":"02_goai_campaign_step/#building-a-simple-email-campaign-step","title":"Building a Simple Email Campaign Step","text":"<p>In the last chapter, we touched upon adding an email step to our \"Webinar Invitation Campaign.\" Let's expand on that:</p> <pre><code># Simplified example: Creating a campaign step\ncampaign_step = Goai::CampaignStep.new(type: \"EMAIL\", prompt: \"Join our webinar!\")\n</code></pre> <p>This code creates a new campaign step.  <code>type: \"EMAIL\"</code> specifies that this step will send an email. <code>prompt: \"Join our webinar!\"</code> provides a starting point for GoAI to generate the actual email content. This prompt can be further refined and personalized later using GoAI Campaign Messages.</p>"},{"location":"02_goai_campaign_step/#under-the-hood","title":"Under the Hood","text":"<p>When a GoAI Campaign runs and reaches a specific step, here's a simplified look at what happens:</p> <pre><code>sequenceDiagram\n    participant GoAI Campaign\n    participant Campaign Step\n    participant Message Generator\n    participant Go Engage\n    GoAI Campaign-&gt;&gt;Campaign Step: Execute Step\n    Campaign Step-&gt;&gt;Message Generator: Generate Message Content\n    Message Generator--&gt;&gt;Campaign Step: Message Content\n    Campaign Step-&gt;&gt;Go Engage: Send Message\n    Go Engage--&gt;&gt;Campaign Step: Message Sent Confirmation\n</code></pre> <ol> <li>Execute Step: The GoAI Campaign triggers the execution of the next Campaign Step.</li> <li>Generate Message Content:  The Campaign Step uses its prompt and AI to generate the content of the message.</li> <li>Send Message: The generated message is sent using Go Engage.</li> </ol>"},{"location":"02_goai_campaign_step/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Goai::CampaignStep</code> model (app/models/goai/campaign_step.rb) defines the structure and behavior of individual steps.</p> <pre><code># app/models/goai/campaign_step.rb (simplified)\nclass Goai::CampaignStep &lt; ApplicationRecord\n  belongs_to :campaign, class_name: \"Goai::Campaign\"\n  # ... other code ...\nend\n</code></pre> <p>The <code>belongs_to :campaign</code> line connects each step to its parent campaign. The <code>type</code> attribute stores the type of step (EMAIL, SMS, etc.), and the <code>prompt</code> attribute stores the instruction for generating the message content.</p>"},{"location":"02_goai_campaign_step/#conclusion","title":"Conclusion","text":"<p>In this chapter, you\u2019ve learned how GoAI Campaign Steps work as individual actions within a campaign.  We saw how different types of steps can be created and how they are executed. In the next chapter, we\u2019ll explore how to further customize these messages using GoAI Campaign Messages.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"03_apppackages/","title":"Chapter 3: AppPackages","text":"<p>In the previous chapter on Conversations, we learned how <code>uui</code> manages individual chat threads within the Messenger.  Now, let's explore how to make those conversations more interactive and useful with <code>AppPackages</code>.</p> <p>Imagine you want to collect some basic information from your users, like their email address, before starting a conversation.  Or maybe you want to offer them helpful resources, like links to your FAQ page. <code>AppPackages</code> allow you to do these things and much more! They're like mini-apps within your chat widget, providing specific functions and enhancing the user experience.</p>"},{"location":"03_apppackages/#what-are-apppackages","title":"What are AppPackages?","text":"<p><code>AppPackages</code> are reusable components that add functionality to your Messenger. Think of them as apps on your phone.  They can:</p> <ul> <li>Display interactive UI elements (buttons, forms, lists)</li> <li>Collect user information</li> <li>Integrate with third-party services</li> <li>Show dynamic content</li> </ul>"},{"location":"03_apppackages/#building-our-first-apppackage","title":"Building our first AppPackage","text":"<p>Let's build a simple AppPackage that greets the user with a welcome message.  This is like having a friendly store greeter.</p> <p>First, we define the structure and content of our AppPackage using a JSON-like format. This structure is called <code>definitions</code>:</p> <pre><code>// Simplified AppPackage definition\nconst myPackage = {\n  name: \"WelcomeMessage\",\n  definitions: [\n    { type: \"text\", text: \"Hello there!\" }\n  ]\n};\n</code></pre> <p>This definition creates an AppPackage named \"WelcomeMessage\" which simply displays the text \"Hello there!\".  The <code>type: \"text\"</code> indicates we want to display a simple text message.</p>"},{"location":"03_apppackages/#integrating-the-apppackage-into-the-messenger","title":"Integrating the AppPackage into the Messenger","text":"<p>Next, we need to add our AppPackage to the Messenger's home screen.  This is like placing our greeter at the store entrance.  We do this by configuring our app settings (simplified example):</p> <pre><code>// Simplified app configuration (backend)\nconst app = { \n  // ... other settings ...\n  visitor_home_apps: [ myPackage ]\n};\n</code></pre> <p>This adds our <code>myPackage</code> to the <code>visitor_home_apps</code> array, which tells the <code>Messenger</code> to display it on the home screen.</p>"},{"location":"03_apppackages/#under-the-hood","title":"Under the Hood","text":"<p>When a user opens the Messenger, it fetches the configured <code>AppPackages</code> from the server and renders them based on their definitions.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n    participant AppPackage\n\n    User-&gt;&gt;Browser: Opens the Messenger\n    Browser-&gt;&gt;Messenger: Requests home screen content\n    Messenger-&gt;&gt;Server: Requests AppPackages\n    Server--&gt;&gt;Messenger: Sends AppPackage definitions\n    Messenger-&gt;&gt;AppPackage: Renders the AppPackage UI\n    Browser-&gt;&gt;User: Displays the welcome message\n</code></pre> <p>The <code>Messenger</code> uses a component to handle the rendering of <code>AppPackages</code>. Here's a simplified example:</p> <pre><code>// app/javascript/packages/components/src/components/packageBlocks/baseInserter.tsx (simplified)\n// ... other code ...\n{p &amp;&amp; (\n  &lt;DefinitionRenderer \n    schema={p.definitions} \n    // ... other props ...\n  /&gt;\n)}\n// ... other code ...\n</code></pre> <p>This code snippet shows how the <code>DefinitionRenderer</code> component uses the <code>definitions</code> from the <code>AppPackage</code> (represented by <code>p</code>) to render the UI.</p>"},{"location":"03_apppackages/#more-complex-apppackages","title":"More Complex AppPackages","text":"<p>We can create more complex AppPackages by adding more elements to the <code>definitions</code> array.  For instance, we can add a button:</p> <pre><code>const myPackage = {\n  // ...\n  definitions: [\n    // ...\n    { \n      type: \"button\", \n      label: \"Click me!\", \n      action: { type: \"submit\" } // Action to perform on click\n    }\n  ]\n};\n</code></pre> <p>This adds a button labeled \"Click me!\" to our AppPackage. The <code>action</code> property defines what happens when the button is clicked. In this case, it triggers a \"submit\" action, which can be handled to perform specific tasks.</p>"},{"location":"03_apppackages/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about <code>AppPackages</code> and how they extend the functionality of the Messenger.  We built a simple welcome message AppPackage and explored how to integrate it into the Messenger's home screen. We also saw how to create more complex AppPackages with interactive elements like buttons.  In the next chapter, we'll explore Bot Tasks, which automate actions and responses within your conversations.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"03_goai_campaign_message/","title":"Chapter 3: GoAI Campaign Message","text":"<p>Continuing from our discussion on GoAI Campaign Steps, let's explore how to personalize the content of each step using GoAI Campaign Messages.</p> <p>Imagine you\u2019re sending out invitations to a webinar. You wouldn't send the exact same email to everyone. You might want to address people by name, mention their company, or tailor the message based on their past interactions with your business. That's what GoAI Campaign Messages allow you to do.  They provide the personalized content delivered within each GoAI Campaign Step.</p>"},{"location":"03_goai_campaign_message/#key-concepts","title":"Key Concepts","text":"<ul> <li>Personalized Content:  A GoAI Campaign Message holds the specific content to be delivered, like the text of an email, an SMS message, or the script for a phone call.  This content can be personalized using data from your GoAI Campaign's target audience.</li> <li>Connection to Campaign Step: Each GoAI Campaign Step can have one or more associated Campaign Messages.  This allows you to have variations in your messaging within a single step. For example, you could have different email templates for different segments of your audience within the same email sending step.</li> </ul>"},{"location":"03_goai_campaign_message/#building-personalized-messages","title":"Building Personalized Messages","text":"<p>Let's enhance our \"Webinar Invitation Campaign\" email step with personalized messages:</p> <pre><code># Simplified example: Creating a campaign message\n\ncontact = { \"FIRST_NAME\" =&gt; \"Alice\", \"COMPANY_NAME\" =&gt; \"Acme Corp\" }\nmessage_content = \"Hi #{contact[\"FIRST_NAME\"]}, join our webinar tailored for professionals at #{contact[\"COMPANY_NAME\"]}!\"\n\ncampaign_message = Goai::CampaignMessage.new(messages: [{ \"type\" =&gt; \"EMAIL\", \"body\" =&gt; message_content}])\n</code></pre> <p>This code creates a new Campaign Message.  The <code>messages</code> attribute holds an array of message details. In this simple case, we have one message of type \"EMAIL\" with a personalized body.</p>"},{"location":"03_goai_campaign_message/#under-the-hood","title":"Under the Hood","text":"<p>When a GoAI Campaign runs and reaches a step requiring personalized content, here's what happens:</p> <pre><code>sequenceDiagram\n    participant GoAI Campaign\n    participant Campaign Step\n    participant Campaign Message\n    participant Go Engage\n    GoAI Campaign-&gt;&gt;Campaign Step: Execute Step\n    Campaign Step-&gt;&gt;Campaign Message: Fetch Personalized Content\n    Campaign Message--&gt;&gt;Campaign Step: Content for Alice from Acme Corp\n    Campaign Step-&gt;&gt;Go Engage: Send Message with Personalized Content\n    Go Engage--&gt;&gt;Campaign Step: Message Sent Confirmation\n</code></pre> <ol> <li>Execute Step: The campaign triggers the execution of a Campaign Step.</li> <li>Fetch Personalized Content: The step retrieves the personalized content from the relevant Campaign Message.  This content is tailored based on the recipient's information.</li> <li>Send Message: Go Engage sends the personalized message.</li> </ol>"},{"location":"03_goai_campaign_message/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Goai::CampaignMessage</code> model (app/models/goai/campaign_message.rb) stores and manages these personalized messages.</p> <pre><code># app/models/goai/campaign_message.rb (simplified)\nclass Goai::CampaignMessage &lt; ApplicationRecord\n  belongs_to :campaign, class_name: \"Goai::Campaign\"\n  serialize :messages, coder: JSON # Stores message details\nend\n</code></pre> <p>The <code>serialize :messages</code> line allows storing complex message data (like subject, body, etc.) as JSON.  The <code>belongs_to :campaign</code> line connects the message to its parent campaign.</p>"},{"location":"03_goai_campaign_message/#conclusion","title":"Conclusion","text":"<p>In this chapter, we explored how GoAI Campaign Messages enable personalized content within your automated campaigns.  You learned how to create these messages and how they work with GoAI Campaign Steps.  Next, we'll look at how to orchestrate more complex sequences of actions using Engage Sequences.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"04_bot_tasks/","title":"Chapter 4: Bot Tasks","text":"<p>In the previous chapter on AppPackages, we learned how to add interactive elements to our Messenger. Now, let's explore how to automate conversations with <code>Bot Tasks</code>.  Imagine you want to greet users, ask qualifying questions, and provide helpful resources automatically.  Bot Tasks let you do exactly that! They're like automated scripts that guide the conversation based on user input.</p>"},{"location":"04_bot_tasks/#automating-a-welcome-message","title":"Automating a Welcome Message","text":"<p>Let's say we want to create a bot that welcomes users and asks for their email address.  This is like having a receptionist who greets everyone and collects contact information.</p> <p>A Bot Task is composed of different paths. Let\u2019s start by creating a simple path:</p> <pre><code>// Simplified Bot Task definition (backend)\nconst myBotTask = {\n  title: \"Welcome Bot\",\n  paths: [\n    {\n      title: \"Welcome Path\",\n      steps: [\n        { type: \"text\", text: \"Hello! Welcome to our store.\" }\n      ]\n    }\n  ]\n}\n</code></pre> <p>This defines a Bot Task named \"Welcome Bot\" with one path named \"Welcome Path\".  The path has one step that displays a simple welcome message. <code>type: \"text\"</code> is similar to how we defined text in AppPackages.</p>"},{"location":"04_bot_tasks/#adding-user-input","title":"Adding User Input","text":"<p>Now, let's ask for the user's email.  We'll add another step to our path:</p> <pre><code>// Simplified Bot Task definition (backend)\n// ... previous code ...\n      steps: [\n        // ... previous step ...\n        { type: \"input\", label: \"Your Email\", name: \"email\" }\n      ]\n// ... remaining code ...\n</code></pre> <p>We've added a step with <code>type: \"input\"</code>. This will display a text field where the user can enter their email address. The <code>label</code> sets the text displayed next to the field, and <code>name</code> is used to identify the collected value.</p>"},{"location":"04_bot_tasks/#triggering-the-bot-task","title":"Triggering the Bot Task","text":"<p>We can trigger our Bot Task when a new Conversation starts.  This is like instructing our receptionist to greet every new customer.  We do this in our app settings (simplified example):</p> <pre><code>// Simplified app configuration (backend)\nconst app = {\n  // ... other settings ...\n  new_conversations_bot_task: myBotTask\n};\n</code></pre> <p>This configuration tells the Messenger to run the <code>myBotTask</code> whenever a new conversation begins.</p>"},{"location":"04_bot_tasks/#under-the-hood","title":"Under the Hood","text":"<p>When a user starts a chat, the <code>Messenger</code> initiates the designated Bot Task. The Bot Task follows the defined path, executing each step sequentially.</p> <pre><code>sequenceDiagram\n  participant User\n  participant Browser\n  participant Messenger\n  participant Server\n  participant Bot Task\n\n  User-&gt;&gt;Browser: Starts a chat\n  Browser-&gt;&gt;Messenger: New conversation event\n  Messenger-&gt;&gt;Server: Triggers Bot Task\n  Server-&gt;&gt;Bot Task: Executes \"Welcome Path\"\n  Bot Task--&gt;&gt;Messenger: Sends welcome message\n  Messenger-&gt;&gt;Browser: Displays welcome message\n  Bot Task--&gt;&gt;Messenger: Sends email input field\n  Messenger-&gt;&gt;Browser: Displays email input field\n</code></pre> <p>The <code>Messenger</code> component interacts with the server to execute the <code>Bot Task</code>. Relevant code snippets (heavily simplified):</p> <pre><code>// app/javascript/controllers/bots_controller.js (simplified)\n// ... other code ...\ninitialize() {\n  // ... initialization logic\n}\n// ... other code ...\n</code></pre> <p>This <code>bots_controller.js</code> file handles the logic for displaying and interacting with Bot Tasks within the Messenger.</p>"},{"location":"04_bot_tasks/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about Bot Tasks and how they automate conversations.  We built a simple Bot Task that welcomes users and collects their email.  We also explored how to trigger the Bot Task at the start of a new Conversation. In the next chapter, we will learn about Tours, which guide users through specific features of your application.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"04_engage_sequence/","title":"Chapter 4: Engage Sequence","text":"<p>Building on our knowledge of GoAI Campaigns, GoAI Campaign Steps, and GoAI Campaign Messages, let's explore the powerful concept of Engage Sequences.</p> <p>Imagine you want to nurture leads over time with a series of automated messages.  You might send a welcome email, followed by a product demo video link a few days later, and finally, a special offer a week after that.  Doing this manually for each lead would be tedious.  Engage Sequences automate this entire process, much like an automated email drip campaign.</p>"},{"location":"04_engage_sequence/#key-concepts","title":"Key Concepts","text":"<p>An Engage Sequence is like a sophisticated GoAI Campaign specifically designed for multi-step, automated communication.  Here\u2019s a breakdown:</p> <ul> <li>Enrollment: Contacts are enrolled in a sequence, similar to adding them to an email list.</li> <li>Steps:  Just like GoAI Campaign Steps, an Engage Sequence consists of multiple steps, each representing a specific communication action (e.g., sending an email, SMS, making a call).</li> <li>Automated Sending:  The system automatically sends messages at pre-defined intervals or based on specific triggers, like a contact opening an email or clicking a link.</li> </ul>"},{"location":"04_engage_sequence/#building-a-simple-engage-sequence","title":"Building a Simple Engage Sequence","text":"<p>Let's create a simple email sequence to welcome new leads:</p> <ol> <li> <p>Create a Sequence: First, you create a new Engage Sequence and give it a descriptive name like \"New Lead Welcome Sequence.\"</p> </li> <li> <p>Add Steps: You add steps to the sequence, defining the type of communication and the content for each step. For example:</p> <p><pre><code># Simplified example - Adding an email step\nsequence_step1 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 0, wait_mode: \"minute\") # Send immediately\nsequence_step2 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 3, wait_mode: \"day\") # Send after 3 days\n</code></pre> This code creates two email steps. The first step sends an email immediately (<code>wait_time: 0</code>). The second step sends an email after a 3-day delay (<code>wait_time: 3</code>, <code>wait_mode: \"day\"</code>).  You'll define the actual email content using Engage Sequence Step Content.</p> </li> <li> <p>Enroll Contacts:  You enroll contacts into your sequence. This is handled by Engage Sequence Membership.</p> </li> </ol>"},{"location":"04_engage_sequence/#under-the-hood","title":"Under the Hood","text":"<p>When a contact is enrolled in an active Engage Sequence:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Engage Sequence\n    participant Sequence Step\n    participant Go Engage\n    User-&gt;&gt;Engage Sequence: Enroll Contact\n    Activate Engage Sequence\n    loop For each step\n        Engage Sequence-&gt;&gt;Sequence Step: Execute Step\n        Sequence Step-&gt;&gt;Go Engage: Send Message\n        Go Engage--&gt;&gt;Sequence Step: Message Sent Confirmation\n    end\n</code></pre> <ol> <li>Enroll Contact: A user is enrolled in the sequence.</li> <li>Activate Engage Sequence: The sequence becomes active for the user.</li> <li>Execute Step: The sequence executes each step in order, sending the corresponding message through Go Engage.</li> </ol>"},{"location":"04_engage_sequence/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::Sequence</code> model (app/models/engage/sequence.rb) is at the heart of this functionality:</p> <pre><code># app/models/engage/sequence.rb (simplified)\nclass Engage::Sequence &lt; ApplicationRecord\n  has_many :sequence_steps\n  # ... other code ...\nend\n</code></pre> <p>The <code>has_many :sequence_steps</code> establishes the relationship between a sequence and its steps.</p>"},{"location":"04_engage_sequence/#conclusion","title":"Conclusion","text":"<p>This chapter introduced Engage Sequences, powerful tools for automated, multi-step communication. We covered the basic concepts and a simple example of creating an email sequence.  In the next chapter, we'll dive into the details of individual steps with Engage Sequence Step.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"05_engage_sequence_step/","title":"Chapter 5: Engage Sequence Step","text":"<p>Continuing from our discussion on Engage Sequences, let's dive into the individual components that make them tick: Engage Sequence Steps.</p> <p>Imagine you're baking a cake. The entire recipe is the \"Engage Sequence,\" but each instruction, like \"mix the dry ingredients\" or \"bake for 30 minutes,\" is an \"Engage Sequence Step.\"  Each step represents a specific action within the sequence.</p>"},{"location":"05_engage_sequence_step/#key-concepts","title":"Key Concepts","text":"<ul> <li>Type:  Specifies what kind of action the step performs, such as sending an email (<code>Engage::EmailStep</code>), an SMS (<code>Engage::SmsStep</code>), or making a call (<code>Engage::VoiceAiStep</code>). You'll learn more about step types in the next chapter, Engage Sequence Step Content.</li> <li>Wait Time:  Defines how long to wait before executing this step after the previous one. This creates the delay between messages in your sequence.</li> <li>Wait Mode: Specifies the unit of time for the <code>wait_time</code>: minutes, hours, or days.</li> </ul>"},{"location":"05_engage_sequence_step/#building-a-simple-email-sequence-step","title":"Building a Simple Email Sequence Step","text":"<p>Let's add two email steps to our \"New Lead Welcome Sequence\":</p> <pre><code># First step: Send a welcome email immediately\nsequence_step1 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 0, wait_mode: \"minute\")\n\n# Second step: Send a follow-up email 3 days later\nsequence_step2 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 3, wait_mode: \"day\")\n</code></pre> <p>The first step sends an email immediately after a contact is enrolled in the sequence (<code>wait_time: 0</code>).  The second step sends another email 3 days after the first one (<code>wait_time: 3</code>, <code>wait_mode: \"day\"</code>).  The actual content of these emails is handled by Engage Sequence Step Content, which we'll cover in the next chapter.</p>"},{"location":"05_engage_sequence_step/#under-the-hood","title":"Under the Hood","text":"<p>When an Engage Sequence is running, here's how it processes each step:</p> <pre><code>sequenceDiagram\n    participant Sequence\n    participant Step 1\n    participant Go Engage\n    participant Step 2\n    Sequence-&gt;&gt;Step 1: Execute\n    Step 1-&gt;&gt;Go Engage: Send Email 1\n    Go Engage--&gt;&gt;Step 1: Confirmation\n    Note right of Step 1: Wait 3 days\n    Sequence-&gt;&gt;Step 2: Execute\n    Step 2-&gt;&gt;Go Engage: Send Email 2\n    Go Engage--&gt;&gt;Step 2: Confirmation\n</code></pre> <ol> <li>Execute: The sequence executes the current step.</li> <li>Send Message:  The step triggers Go Engage to send the message (in this case, an email).</li> <li>Confirmation: Go Engage confirms that the message was sent.</li> <li>Wait: The sequence waits the specified <code>wait_time</code> before proceeding to the next step.</li> </ol>"},{"location":"05_engage_sequence_step/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceStep</code> model (app/models/engage/sequence_step.rb) defines the structure and behavior of individual steps:</p> <pre><code># app/models/engage/sequence_step.rb (simplified)\nclass Engage::SequenceStep &lt; ApplicationRecord\n  belongs_to :sequence, class_name: \"Engage::Sequence\"\n  # ... other code related to content, events, etc. ...\nend\n</code></pre> <p>The <code>belongs_to :sequence</code> line links each step to its parent sequence. The <code>type</code>, <code>wait_time</code>, and <code>wait_mode</code> attributes store the step's configuration.</p>"},{"location":"05_engage_sequence_step/#conclusion","title":"Conclusion","text":"<p>This chapter explained how Engage Sequence Steps work as the individual actions within an Engage Sequence. We explored the key concepts of step type, wait time, and wait mode. In the next chapter, we'll delve into Engage Sequence Step Content to learn how to define the actual messages sent in each step.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"05_tours/","title":"Chapter 5: Tours","text":"<p>Following our discussion on automating actions with Bot Tasks, let's explore how to guide users through your application with <code>Tours</code>. Imagine you've just redesigned your website and want to highlight the new features to your users.  Tours provide a step-by-step walkthrough, highlighting key elements and explaining their functionality. They act like a guide, pointing out important areas and providing helpful information.</p>"},{"location":"05_tours/#guiding-users-through-new-features","title":"Guiding Users Through New Features","text":"<p>Let's say you've added a new \"Help\" button to your Messenger and want to ensure your users know about it. We can create a Tour to highlight this button.</p> <p>A Tour consists of several steps. Each step highlights a specific element on the page and provides a description.  Let\u2019s create our first step:</p> <pre><code>// Simplified Tour step definition (backend)\nconst tourStep = {\n  target: \"#help-button\", // CSS selector for the Help button\n  serialized_content: JSON.stringify({ blocks: [{ type: \"text\", text: \"Click here for help!\" }]})\n};\n</code></pre> <p>This defines a single step in our Tour. <code>target</code> specifies the HTML element to highlight (in this case, the Help button using its ID).  <code>serialized_content</code> contains the message to display next to the highlighted element.  Notice how it uses a structure similar to AppPackages for the content definition.</p>"},{"location":"05_tours/#creating-a-tour","title":"Creating a Tour","text":"<p>Now let\u2019s create a Tour using this step.  We\u2019ll keep it simple with just one step for now:</p> <pre><code>// Simplified Tour definition (backend)\nconst myTour = {\n  url: \"/help\", // URL where the Tour should be active\n  steps: [tourStep]\n};\n</code></pre> <p>This creates a Tour that will be active on the \"/help\" URL.  The <code>steps</code> array contains all the steps of the Tour, in this case just our single <code>tourStep</code>.</p>"},{"location":"05_tours/#enabling-the-tour","title":"Enabling the Tour","text":"<p>Finally, we need to enable our Tour so it's displayed to the user.  This is like telling our guide to start the tour.  We\u2019ll do this by setting the Tour state to \u201cenabled\u201d (simplified backend example):</p> <pre><code>// Simplified code to enable a Tour (backend)\nmyTour.state = \"enabled\";\nmyTour.save();\n</code></pre> <p>This code enables <code>myTour</code> and saves it, making it active for users visiting the specified URL.</p>"},{"location":"05_tours/#under-the-hood","title":"Under the Hood","text":"<p>When a user visits the specified URL, the Messenger checks for any enabled Tours. If it finds one, it displays the Tour steps to the user.</p> <pre><code>sequenceDiagram\n  participant User\n  participant Browser\n  participant Messenger\n  participant Server\n  participant Tour\n\n  User-&gt;&gt;Browser: Visits /help\n  Browser-&gt;&gt;Messenger: Requests page content\n  Messenger-&gt;&gt;Server: Checks for enabled Tours\n  Server--&gt;&gt;Messenger: Sends Tour data\n  Messenger-&gt;&gt;Tour: Starts the Tour\n  Browser-&gt;&gt;User: Displays Tour step highlighting the Help button\n</code></pre> <p>The <code>UserTour</code> component handles the display and logic of the Tour in the frontend.  Here's a simplified snippet demonstrating how the Tour steps are rendered:</p> <pre><code>// app/javascript/packages/messenger/src/client_messenger/UserTour.tsx (simplified)\n// ... other code ...\n&lt;Tour\n  steps={this.prepareJoyRidyContent()} // Prepare steps for display\n  isOpen={this.state.run} // Control Tour visibility\n  // ... other props ...\n/&gt;\n// ... other code ...\n</code></pre> <p>This code utilizes the <code>reactour</code> library to render the Tour. <code>prepareJoyRidyContent</code> processes the Tour step definitions for the library.</p>"},{"location":"05_tours/#conclusion","title":"Conclusion","text":"<p>This chapter introduced Tours and how they guide users through your application. We built a simple Tour to highlight a new Help button and saw how to enable it for a specific URL.  In the next chapter, we'll explore Customization options, allowing you to tailor the appearance and behavior of your Messenger to fit your brand.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"06_customization/","title":"Chapter 6: Customization","text":"<p>In the previous chapter on Tours, we learned how to guide users through your application. Now, let's explore how to make your Messenger truly your own with <code>Customization</code> options. Imagine you're decorating your storefront\u2014you want the colors, logo, and overall style to match your brand.  Customization options allow you to tailor the appearance of the Messenger to achieve just that!</p>"},{"location":"06_customization/#branding-your-messenger","title":"Branding Your Messenger","text":"<p>Let's say you want to change the main color of your Messenger to match your brand's primary color, which is a vibrant green.  Customization options make this easy!</p>"},{"location":"06_customization/#customizing-colors","title":"Customizing Colors","text":"<p>You can customize the colors of your Messenger by setting the <code>customization_colors</code> attribute of your app.  Think of it as choosing the paint for your storefront.</p> <pre><code>// Simplified app configuration (backend)\nconst app = {\n  // ... other settings ...\n  customization_colors: {\n    primary: \"#00FF00\" // Vibrant green\n  }\n};\n</code></pre> <p>This sets the primary color of the Messenger to vibrant green. You can also customize the secondary color and other aspects of the appearance.</p>"},{"location":"06_customization/#adding-a-logo","title":"Adding a Logo","text":"<p>You can also add your brand's logo to the Messenger, just like placing a sign above your storefront.  This is done by setting the <code>logo_url</code> attribute:</p> <pre><code>// Simplified app configuration (backend)\nconst app = {\n  // ... other settings ...\n  logo_url: \"https://example.com/my_logo.png\"\n};\n</code></pre> <p>This sets the Messenger's logo to the image located at the specified URL.</p>"},{"location":"06_customization/#under-the-hood","title":"Under the Hood","text":"<p>When the Messenger loads, it retrieves the customization settings from the server. These settings are then applied to the Messenger's styles, changing its appearance.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n\n    User-&gt;&gt;Browser: Opens the Messenger\n    Browser-&gt;&gt;Messenger: Requests customization settings\n    Messenger-&gt;&gt;Server: Fetches customization data\n    Server--&gt;&gt;Messenger: Sends customization colors and logo URL\n    Messenger-&gt;&gt;Browser: Applies styles to the Messenger\n    Browser-&gt;&gt;User: Displays the customized Messenger\n</code></pre> <p>The <code>style_settings_controller.js</code> file (among others) handles applying the customization settings on the client-side.  Here's a simplified example:</p> <pre><code>// app/javascript/controllers/style_settings_controller.js (simplified)\n// ... other code ...\nconnect() {\n  // ... Logic to apply customization settings ...\n}\n// ... other code ...\n</code></pre> <p>This <code>connect</code> function is called when the controller is initialized, allowing it to apply the custom styles to the Messenger.</p> <p>Tailwind styles and CSS variables are used to apply these customizations dynamically:</p> <pre><code>// engines/astro-plain/tailwind.config.js (simplified)\n// ... other configurations\ntheme: {\n  extend: {\n    colors: {\n      // ... other colors,\n      brand: {\n        500: \"#ec4899\", // Example brand color\n      }\n    }\n  }\n}\n// ...\n</code></pre> <p>This snippet shows how brand colors are defined in the tailwind config, and they can then be used throughout the application.</p>"},{"location":"06_customization/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned how to customize the appearance of the Messenger using <code>Customization</code> options.  We explored how to change colors, add a logo, and saw how these settings are applied under the hood.  This allows you to create a consistent brand experience within your chat widget. In the next chapter, we'll discuss Translations, allowing you to make your Messenger accessible to a wider audience.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"06_engage_sequence_step_content/","title":"Chapter 6: Engage Sequence Step Content","text":"<p>Continuing from our discussion on Engage Sequence Steps, let's explore how to define the actual content of each step: the Engage Sequence Step Content.</p> <p>Imagine you're sending a postcard.  The address and stamp tell the postal service where to send it (Engage Sequence Step), but the message inside is what you actually want to communicate. That's the role of Engage Sequence Step Content. It holds the message template for each step in a sequence. It's like the content of your postcard.</p>"},{"location":"06_engage_sequence_step_content/#key-concepts","title":"Key Concepts","text":"<ul> <li>Message Template:  This is the actual message, like an email body, SMS text, or call script. It can use placeholders (like <code>{{FIRST_NAME}}</code>) for personalization. These placeholders are replaced with real data when the message is sent, similar to mail merge.</li> <li>Connection to Step: Each Engage Sequence Step has one or more associated Step Content items. This lets you have different message variations within a single step.  For example, you could A/B test different email subject lines.</li> </ul>"},{"location":"06_engage_sequence_step_content/#building-content-for-email-steps","title":"Building Content for Email Steps","text":"<p>Let\u2019s add content to the email steps in our \"New Lead Welcome Sequence\":</p> <pre><code># Simplified example - Adding content to the first email step\ncontent1 = Engage::SequenceStepContent.new(\n  stepable_type: \"Engage::EmailStep\", # Specify content type\n  stepable_attributes: { # The actual content\n    subject: \"Welcome to our platform!\",\n    body: \"Hi {{FIRST_NAME}}, thanks for joining!\"\n  }\n)\nsequence_step1.sequence_contents &lt;&lt; content1\n\n# Simplified example - Adding content to the second email step (3 days later)\ncontent2 = Engage::SequenceStepContent.new(\n  stepable_type: \"Engage::EmailStep\",\n  stepable_attributes: {\n    subject: \"Checking in!\",\n    body: \"Hi {{FIRST_NAME}}, how are you finding our platform?\"\n  }\n)\nsequence_step2.sequence_contents &lt;&lt; content2\n</code></pre> <p>This code creates two <code>Engage::SequenceStepContent</code> objects.  <code>stepable_type</code> tells us this content is for an email step. <code>stepable_attributes</code> holds the actual email content: subject and body. Notice the <code>{{FIRST_NAME}}</code> placeholder, which will be replaced with the recipient's name when the email is sent.</p>"},{"location":"06_engage_sequence_step_content/#under-the-hood","title":"Under the Hood","text":"<p>When a step in a sequence is executed:</p> <pre><code>sequenceDiagram\n    participant Engage Sequence\n    participant Sequence Step\n    participant Step Content\n    participant Go Engage\n    Engage Sequence-&gt;&gt;Sequence Step: Execute Step\n    Sequence Step-&gt;&gt;Step Content: Fetch Message Content\n    Step Content--&gt;&gt;Sequence Step: Email Subject &amp; Body with Placeholders\n    Sequence Step-&gt;&gt;Go Engage: Send Personalized Email\n    Go Engage--&gt;&gt;Sequence Step: Confirmation\n</code></pre> <ol> <li>Execute Step:  The sequence executes the current step.</li> <li>Fetch Message Content: The step retrieves the message template from the associated Step Content.</li> <li>Send Personalized Email:  The placeholders in the template are replaced with the contact's data, and the personalized email is sent via Go Engage.</li> </ol>"},{"location":"06_engage_sequence_step_content/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceStepContent</code> model (app/models/engage/sequence_step_content.rb) is responsible for storing and managing step content.</p> <pre><code># app/models/engage/sequence_step_content.rb (simplified)\nclass Engage::SequenceStepContent &lt; ApplicationRecord\n  belongs_to :stepable, polymorphic: true # Connects to the specific content type (e.g., EmailStep)\n  belongs_to :sequence_step # Connects to the parent step\n  # ... other code ...\nend\n</code></pre> <p>The <code>belongs_to :stepable</code> relationship allows different types of content (email, SMS, etc.) to be associated with a step. The <code>belongs_to :sequence_step</code> connects the content to its parent step.</p>"},{"location":"06_engage_sequence_step_content/#conclusion","title":"Conclusion","text":"<p>This chapter covered Engage Sequence Step Content, which holds the actual message templates for your sequence steps. You learned how to create and associate content with email steps, using placeholders for personalization.  Next, we'll look at how contacts are enrolled in sequences with Engage Sequence Membership.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"07_engage_sequence_membership/","title":"Chapter 7: Engage Sequence Membership","text":"<p>Continuing from our discussion on Engage Sequence Step Content, let's learn how to actually enroll contacts in our sequences: using Engage Sequence Membership.</p> <p>Imagine you've created a fantastic automated email sequence to welcome new leads.  You have your emails ready (Engage Sequence Step Content) and the timing defined (Engage Sequence Step). But how do you get people into this sequence? That's precisely what Engage Sequence Membership handles. It's like giving someone a ticket to your automated email show.</p>"},{"location":"07_engage_sequence_membership/#key-concepts","title":"Key Concepts","text":"<ul> <li>Connection: An Engage Sequence Membership links a contact (GoAI Campaign's Target Audience) to a specific Engage Sequence.  It's like assigning a seat to a ticket holder.</li> <li>Progress Tracking: It keeps track of the contact's journey through the sequence. Which emails have they received? Have they opened or clicked any links? It's like a program for your email show, marking where each attendee is.</li> <li>Status:  It records the contact's current status in the sequence: are they actively receiving messages, paused, or finished? Think of it as updating the attendee's status:  \"currently watching,\" \"intermission,\" or \"show over.\"</li> </ul>"},{"location":"07_engage_sequence_membership/#enrolling-a-contact","title":"Enrolling a Contact","text":"<p>Let's enroll a contact named Alice into our \"New Lead Welcome Sequence\":</p> <pre><code># Simplified example - Enrolling a contact (app_user) in a sequence\nalice = AppUser.find_by(first_name: \"Alice\") # Find Alice in our database\nsequence = Engage::Sequence.find_by(name: \"New Lead Welcome Sequence\") # Find the sequence\n\nmembership = Engage::SequenceMembership.create(app_user: alice, sequence: sequence)\n</code></pre> <p>This creates a new <code>Engage::SequenceMembership</code> that connects Alice (<code>app_user</code>) to the \"New Lead Welcome Sequence\" (<code>sequence</code>). Now Alice is enrolled and will start receiving the emails according to the sequence's steps.</p>"},{"location":"07_engage_sequence_membership/#under-the-hood","title":"Under the Hood","text":"<p>When a new <code>Engage::SequenceMembership</code> is created:</p> <pre><code>sequenceDiagram\n    participant User\n    participant App\n    participant SequenceMembership\n    participant Sequence\n    participant Go Engage\n    User-&gt;&gt;App: Enroll Contact in Sequence\n    App-&gt;&gt;SequenceMembership: Create Membership\n    SequenceMembership-&gt;&gt;Sequence: Activate Sequence for Contact\n    Sequence-&gt;&gt;Go Engage: Start Sending Messages\n</code></pre> <ol> <li>Create Membership:  A new <code>Engage::SequenceMembership</code> is created, linking the contact and the sequence.</li> <li>Activate Sequence: The sequence becomes active for this contact.</li> <li>Start Sending:  Go Engage begins sending the messages according to the sequence's steps.</li> </ol>"},{"location":"07_engage_sequence_membership/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceMembership</code> model (app/models/engage/sequence_membership.rb) manages the relationship between contacts and sequences.</p> <pre><code># app/models/engage/sequence_membership.rb (simplified)\nclass Engage::SequenceMembership &lt; ApplicationRecord\n  belongs_to :app_user # Connects to the contact\n  belongs_to :sequence, class_name: \"Engage::Sequence\" # Connects to the sequence\n  # ... other code for tracking progress, status, etc. ...\nend\n</code></pre> <p>The <code>belongs_to :app_user</code> and <code>belongs_to :sequence</code> lines establish the crucial connections. Other attributes and methods in this model handle tracking the contact's progress, status, and interactions within the sequence.</p>"},{"location":"07_engage_sequence_membership/#conclusion","title":"Conclusion","text":"<p>In this chapter, we explored Engage Sequence Membership, which is the key to enrolling contacts in your automated sequences. You learned how to create a membership and saw how it works behind the scenes. In the next chapter, we'll explore how to track specific interactions within a sequence using Engage Sequence Event.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"07_translations/","title":"Chapter 7: Translations","text":"<p>In the previous chapter on Customization, we learned how to visually tailor the Messenger to reflect your brand.  Now, let's explore how to make it speak your users' language\u2014literally!  <code>Translations</code> in <code>uui</code> allow you to offer your Messenger experience in multiple languages, expanding your reach and making your users feel at home.</p> <p>Imagine you have customers from all over the world. Wouldn't it be great if they could interact with your Messenger in their native language?  Translations make this possible!</p>"},{"location":"07_translations/#making-your-messenger-multilingual","title":"Making Your Messenger Multilingual","text":"<p>Let's say you want to offer your Messenger in both English and Spanish.  This is like having staff who can speak both languages.</p> <p>The core of translations in <code>uui</code> relies on YAML files containing key-value pairs.  The keys represent the original text, and the values are the translated text.</p> <pre><code># config/locales/en.yml (English)\nen:\n  start_conversation: \"Start a conversation\"\n  hello: \"Hello\"\n\n# config/locales/es.yml (Spanish)\nes:\n  start_conversation: \"Inicia una conversaci\u00f3n\"\n  hello: \"Hola\"\n</code></pre> <p>These files define the translations for the keys \"start_conversation\" and \"hello\" in English and Spanish respectively.</p>"},{"location":"07_translations/#using-translations-in-your-code","title":"Using Translations in your Code","text":"<p>To use these translations in your application, you use the <code>I18n</code> object, which is initialized with the translation data.  Think of the <code>I18n</code> object as a universal translator.</p> <p><pre><code>// app/javascript/locales.js (simplified)\nimport { I18n } from 'i18n-js';\nimport translations from './src/locales/translations.json'; // Compiled translations\n\nconst i18n = new I18n(translations);\ni18n.locale = document.documentElement.lang || 'en'; // Set the locale\nwindow.I18n = i18n; // Make I18n globally available\n</code></pre> This code imports the <code>I18n</code> library, loads the compiled translation data from <code>translations.json</code>, sets the locale based on the user's browser language, and makes the <code>I18n</code> object globally available.</p> <p>Now, you can use the <code>t</code> function (provided by <code>I18n</code>) to translate text in your components:</p> <pre><code>// Example usage in a React component\n// ...other code\n\n&lt;button&gt;{I18n.t(\"start_conversation\")}&lt;/button&gt;\n\n// ...other code\n</code></pre> <p>This code snippet will render a button that displays \"Start a conversation\" if the locale is English, and \"Inicia una conversaci\u00f3n\" if the locale is Spanish.</p>"},{"location":"07_translations/#under-the-hood","title":"Under the Hood","text":"<p>When the user opens the Messenger, the Javascript code detects the user's browser language or uses a default language.  Then, it uses the <code>I18n</code> object to retrieve the appropriate translations.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant I18n\n\n    User-&gt;&gt;Browser: Opens the Messenger\n    Browser-&gt;&gt;Messenger: Sends language preference\n    Messenger-&gt;&gt;I18n: Requests translation for \"start_conversation\"\n    I18n--&gt;&gt;Messenger: Returns translated text (\"Start a conversation\" or \"Inicia una conversaci\u00f3n\")\n    Messenger-&gt;&gt;Browser: Displays the translated text\n    Browser-&gt;&gt;User: Sees the translated button\n</code></pre> <p>The <code>I18n</code> object looks up the key in the loaded translation data and returns the corresponding translated text based on the current locale.</p>"},{"location":"07_translations/#managing-translations-with-crowdin","title":"Managing Translations with Crowdin","text":"<p><code>uui</code> uses Crowdin, a localization management platform, to manage translations efficiently. Crowdin simplifies the process of translating your app into multiple languages.</p> <p>The <code>crowdin.yml</code> file configures which files should be synchronized with Crowdin for translation.  </p> <pre><code># crowdin.yml (simplified)\nfiles:\n  - source: /config/locales/en.yml\n    translation: /config/locales/%two_letters_code%.yml\n</code></pre> <p>This configuration tells Crowdin to use <code>en.yml</code> as the source language file and generate translation files like <code>es.yml</code>, <code>fr.yml</code>, etc. based on the two-letter language codes.</p>"},{"location":"07_translations/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about <code>Translations</code> and how they enable a multilingual Messenger experience. We explored how to define translations in YAML files, use the <code>I18n</code> object to translate text in our components, and how Crowdin streamlines the translation management process. Now you can create a more inclusive and personalized experience for your users worldwide. In the next chapter, we will explore Stimulus Controllers and how they enhance interactivity in your <code>uui</code> application.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"08_engage_sequence_event/","title":"Chapter 8: Engage Sequence Event","text":"<p>Continuing from our discussion on Engage Sequence Membership, let's explore how to track the interactions within a sequence: Engage Sequence Events.</p> <p>Imagine you're running a marathon.  You know who's participating (Engage Sequence Membership), but you also want to track their progress: when they reach certain checkpoints, their pace, or if they stop for a water break.  Engage Sequence Events are like those checkpoints, recording every interaction a contact has within a sequence.</p>"},{"location":"08_engage_sequence_event/#key-concepts","title":"Key Concepts","text":"<ul> <li>Timestamp: Each event has a timestamp, showing when it happened. Think of it as the time recorded at each checkpoint in the marathon.</li> <li>Event Type: This specifies what happened: an email open, a link click, a reply, a bounce, etc.  It's like noting whether the runner grabbed water or just passed the checkpoint.</li> <li>Data:  This provides additional details about the event, like which link was clicked or the content of a reply. It's like recording the runner's pace at a specific checkpoint.</li> </ul>"},{"location":"08_engage_sequence_event/#tracking-an-email-open","title":"Tracking an Email Open","text":"<p>Let's say Alice, who is enrolled in our \"New Lead Welcome Sequence,\" opens the first welcome email.  This action triggers an Engage Sequence Event:</p> <pre><code># Simplified example - Logging an email open event\nevent = Engage::SequenceEvent.create!(\n  event_type: \"opened\", \n  occurred_at: Time.current,\n  sequence_membership: membership, # Alice's membership\n  sequence_step: step # The step that sent the email\n)\n</code></pre> <p>This creates an <code>Engage::SequenceEvent</code> record. <code>event_type: \"opened\"</code> specifies the type of event. <code>occurred_at</code> records the timestamp. The event is linked to Alice's <code>membership</code> and the specific <code>step</code> that triggered it.</p>"},{"location":"08_engage_sequence_event/#under-the-hood","title":"Under the Hood","text":"<p>When a contact interacts with a sequence, here's how an event is logged:</p> <pre><code>sequenceDiagram\n    participant Contact\n    participant Go Engage\n    participant App\n    participant Sequence Event\n    Contact-&gt;&gt;Go Engage: Opens Email\n    Go Engage-&gt;&gt;App: Email Opened Notification\n    App-&gt;&gt;Sequence Event: Create \"opened\" Event\n</code></pre> <ol> <li>Interaction: The contact interacts with the sequence (e.g., opens an email).</li> <li>Notification: Go Engage notifies the application about the interaction.</li> <li>Create Event: The application creates an <code>Engage::SequenceEvent</code> record.</li> </ol>"},{"location":"08_engage_sequence_event/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceEvent</code> model (app/models/engage/sequence_event.rb) stores and manages these events.</p> <pre><code># app/models/engage/sequence_event.rb (simplified)\nclass Engage::SequenceEvent &lt; ApplicationRecord\n  belongs_to :sequence_membership # Connects to the membership\n  belongs_to :sequence_step # Connects to the step\n  # ... other code ...\nend\n</code></pre> <p>The <code>belongs_to :sequence_membership</code> and <code>belongs_to :sequence_step</code> relationships link the event to the relevant membership and step. The <code>event_type</code> and <code>occurred_at</code> attributes store the event's key information. The <code>data</code> attribute can hold additional details as needed.</p>"},{"location":"08_engage_sequence_event/#conclusion","title":"Conclusion","text":"<p>This chapter introduced Engage Sequence Events, essential for tracking contact interactions within your automated sequences. You learned how to create events and how they are logged behind the scenes.  Next, we'll explore how to manage credentials for sending messages with Engage Sequence OAuth Credential.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"08_stimulus_controllers/","title":"Chapter 8: Stimulus Controllers","text":"<p>Following our discussion on Translations, let's dive into a key part of <code>uui</code>'s interactivity: <code>Stimulus Controllers</code>.  Imagine you want a button in your Messenger that, when clicked, reveals extra options.  Stimulus Controllers are like the tiny computers behind such interactive elements. They connect your HTML to JavaScript, enabling dynamic behavior in response to user actions.</p>"},{"location":"08_stimulus_controllers/#making-your-messenger-more-dynamic","title":"Making Your Messenger More Dynamic","text":"<p>Let's say you want to show a welcome message when the Messenger first opens, then hide it when the user clicks a \"Close\" button. This is a perfect use case for a Stimulus Controller.</p>"},{"location":"08_stimulus_controllers/#building-a-simple-controller","title":"Building a Simple Controller","text":"<p>First, let's create a Stimulus Controller to manage this behavior.  Think of it as the small computer controlling our welcome message.</p> <pre><code>// app/javascript/controllers/welcome_controller.js\nimport { Controller } from \"@hotwired/stimulus\"\n\nexport default class extends Controller {\n  connect() {\n    // This code runs when the controller is connected\n    console.log(\"Welcome controller connected!\");\n  }\n\n  hideWelcome() {\n    this.element.style.display = \"none\";\n  }\n}\n</code></pre> <p>This code defines a controller named <code>welcome_controller</code>.  The <code>connect()</code> function is called when the controller is connected to the HTML element.  The <code>hideWelcome()</code> function will hide the element it's attached to.</p>"},{"location":"08_stimulus_controllers/#connecting-the-controller-to-html","title":"Connecting the Controller to HTML","text":"<p>Now, let's connect this controller to our welcome message in the HTML. This is like wiring the computer to the message display.</p> <pre><code>&lt;div data-controller=\"welcome\"&gt;\n  &lt;p&gt;Welcome to our chat!&lt;/p&gt;\n  &lt;button data-action=\"click-&gt;welcome#hideWelcome\"&gt;Close&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>data-controller=\"welcome\"</code> attribute connects the <code>div</code> to our <code>welcome_controller</code>. The <code>data-action=\"click-&gt;welcome#hideWelcome\"</code> attribute tells Stimulus to call the <code>hideWelcome()</code> function when the button is clicked.  <code>click</code> refers to the event and <code>welcome#hideWelcome</code> identifies the controller and method to call.</p>"},{"location":"08_stimulus_controllers/#under-the-hood","title":"Under the Hood","text":"<p>When the page loads, Stimulus scans the HTML for <code>data-controller</code> attributes. It then creates an instance of the corresponding controller and connects it to the element. When the button is clicked, Stimulus handles the event and calls the specified controller method.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Stimulus\n    participant welcome_controller\n\n    User-&gt;&gt;Browser: Clicks the \"Close\" button\n    Browser-&gt;&gt;Stimulus: Triggers the \"click\" event\n    Stimulus-&gt;&gt;welcome_controller: Calls hideWelcome()\n    welcome_controller-&gt;&gt;Browser: Hides the welcome message\n    Browser-&gt;&gt;User: The welcome message disappears\n</code></pre> <p>Stimulus acts as the intermediary, handling the event and delegating the action to the correct controller.  The <code>index.js</code> file is responsible for loading all controllers:</p> <pre><code>// app/javascript/controllers/index.js (simplified)\n// ... other code ...\nimport controllers from './**/*_controller.js';\n\ncontrollers.forEach((controller) =&gt; {\n  application.register(controller.name, controller.module.default);\n});\n</code></pre> <p>This code imports all controllers and registers them with the Stimulus application.</p>"},{"location":"08_stimulus_controllers/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about Stimulus Controllers and how they enhance interactivity in <code>uui</code>.  We built a simple controller to show and hide a welcome message and saw how to connect it to our HTML. This provides a fundamental understanding of how Stimulus brings dynamic behavior to your frontend.  While there's no specific next chapter in this tutorial, exploring the <code>uui</code> codebase further will reveal more advanced uses of Stimulus Controllers, such as managing AppPackages, handling events in the Messenger, and controlling the flow of Bot Tasks.  Keep experimenting and building!</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"09_engage_sequence_oauth_credential/","title":"Chapter 9: Engage Sequence OAuth Credential","text":"<p>Continuing from our discussion on Engage Sequence Events, let's explore how to manage credentials for sending messages: Engage Sequence OAuth Credentials.</p> <p>Imagine you have multiple team members sending emails as part of your automated sequences. Each team member needs their own email account access so they don't all send from the same address.  Engage Sequence OAuth Credentials manage these access \"keys\" for each sequence.  They're like keychains holding keys to different mailboxes, ensuring emails are sent from the right accounts and managing sending limits.</p>"},{"location":"09_engage_sequence_oauth_credential/#key-concepts","title":"Key Concepts","text":"<ul> <li>OAuth Credential:  This is the \"key\" itself, granting access to a specific email account (or other communication channels).  Think of this as a single key on your keychain.</li> <li>Connection to Sequence:  An Engage Sequence can have multiple OAuth Credentials associated with it, like having multiple keys on a keychain for different mailboxes. This allows a sequence to send emails from different accounts.</li> <li>Managing Sending Limits: The system uses these credentials to track and respect daily sending limits for each connected email account, preventing accounts from being flagged as spam.  This is like knowing the daily usage limit for each mailbox.</li> </ul>"},{"location":"09_engage_sequence_oauth_credential/#sending-emails-from-multiple-accounts","title":"Sending Emails from Multiple Accounts","text":"<p>Let's say our \"New Lead Welcome Sequence\" needs to send emails from two different accounts: <code>sales@example.com</code> and <code>marketing@example.com</code>.</p> <ol> <li> <p>Create OAuth Credentials: First, you create OAuth Credentials for each email account. Let's assume these credentials are stored in our database as <code>OauthCredential</code> objects and we have two: <code>sales_credential</code> and <code>marketing_credential</code>.</p> </li> <li> <p>Connect Credentials to Sequence:  We connect these credentials to our sequence:</p> <pre><code># Simplified example - Connecting credentials to a sequence\nsequence = Engage::Sequence.find_by(name: \"New Lead Welcome Sequence\")\nsequence.oauth_credentials &lt;&lt; sales_credential\nsequence.oauth_credentials &lt;&lt; marketing_credential\n</code></pre> </li> </ol> <p>This code adds both <code>sales_credential</code> and <code>marketing_credential</code> to the <code>sequence</code>. Now, the sequence can use either of these credentials when sending emails.</p>"},{"location":"09_engage_sequence_oauth_credential/#under-the-hood","title":"Under the Hood","text":"<p>When a sequence needs to send an email:</p> <pre><code>sequenceDiagram\n    participant Sequence\n    participant OAuth Credentials\n    participant Credential Selector\n    participant Go Engage\n    Sequence-&gt;&gt;Credential Selector: Request Credential\n    Credential Selector-&gt;&gt;OAuth Credentials: Find Available Credential\n    OAuth Credentials--&gt;&gt;Credential Selector: sales@example.com Credential\n    Credential Selector--&gt;&gt;Sequence: sales@example.com Credential\n    Sequence-&gt;&gt;Go Engage: Send Email using Credential\n</code></pre> <ol> <li>Request Credential: The sequence requests an available credential.</li> <li>Find Available Credential: The system checks which credentials are associated with the sequence and selects one that's below its daily sending limit and hasn't been used recently.</li> <li>Send Email: The sequence uses the selected credential to send the email via Go Engage.</li> </ol>"},{"location":"09_engage_sequence_oauth_credential/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceOauthCredential</code> model (app/models/engage/sequence_oauth_credential.rb) manages the association between sequences and credentials.</p> <pre><code># app/models/engage/sequence_oauth_credential.rb (simplified)\nclass Engage::SequenceOauthCredential &lt; ApplicationRecord\n  belongs_to :sequence # Connects to the sequence\n  belongs_to :oauth_credential # Connects to the credential\nend\n</code></pre> <p>The <code>Engage::Sequence</code> model also has a relationship with <code>OauthCredential</code>:</p> <pre><code># app/models/engage/sequence.rb (simplified)\nclass Engage::Sequence &lt; ApplicationRecord\n  has_many :oauth_credentials, through: :sequence_oauth_credentials\n  # ... other code ...\n\n  def next_available_credential\n    sequence_oauth_credentials.available_for_sending.last_used_random.first&amp;.oauth_credential\n  end\nend\n</code></pre> <p>The <code>next_available_credential</code> method finds a credential that's available for sending based on its usage and daily limits.  The <code>available_for_sending</code> scope handles checking these conditions.</p>"},{"location":"09_engage_sequence_oauth_credential/#conclusion","title":"Conclusion","text":"<p>This chapter explained how Engage Sequence OAuth Credentials manage access to email accounts for your sequences, allowing you to send from multiple addresses and manage sending limits.  You learned how to connect credentials to your sequences and saw how the system selects an available credential for sending. This concludes our series on the core components of the <code>uui</code> project. You should now have a good understanding of how to build and manage automated communication sequences.</p> <p>Generated by AI Codebase Knowledge Builder</p>"}]}