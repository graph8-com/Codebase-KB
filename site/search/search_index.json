{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"chat-uui/","title":"Tutorial: chat-uui","text":"<p><code>chat-uui</code> is a React library for building chat user interfaces. It provides components like Threads to display conversations, a Composer for user input, and handles Messages and their Content Parts. It also connects to Runtimes and Assistant Clouds to send messages and use AI Tools.  The UI can be customized with Markdown Text and displayed in an Assistant Modal.</p> <p>Source Repository: None</p> <pre><code>flowchart TD\n    A0[\"Thread\"]\n    A1[\"Runtime\"]\n    A2[\"Message\"]\n    A3[\"Composer\"]\n    A4[\"Content Part\"]\n    A5[\"Model Context\"]\n    A6[\"Assistant Cloud\"]\n    A7[\"Tools and Tool UI\"]\n    A8[\"Markdown Text\"]\n    A9[\"Assistant Modal\"]\n    A0 -- \"Displays\" --&gt; A2\n    A0 -- \"Contains\" --&gt; A3\n    A0 -- \"Uses\" --&gt; A1\n    A0 -- \"Renders\" --&gt; A8\n    A0 -- \"Displayed in\" --&gt; A9\n    A1 -- \"Connects to\" --&gt; A6\n    A1 -- \"Sends/Receives\" --&gt; A2\n    A1 -- \"Uses config from\" --&gt; A5\n    A2 -- \"Composed of\" --&gt; A4\n    A5 -- \"Configures\" --&gt; A7\n    A9 -- \"Contains\" --&gt; A0\n</code></pre>"},{"location":"chat-uui/#chapters","title":"Chapters","text":"<ol> <li>Thread</li> <li>Message</li> <li>Composer</li> <li>Content Part</li> <li>Runtime</li> <li>Assistant Cloud</li> <li>Model Context</li> <li>Tools and Tool UI</li> <li>Markdown Text</li> <li>Assistant Modal</li> </ol> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/01_thread/","title":"Chapter 1: Thread","text":"<p>Imagine you're building a chatbot. You want a place to display the conversation, let the user type messages, and show the chatbot's replies.  This is where the <code>Thread</code> comes in.  The <code>Thread</code> is like the main window of your chatbot, holding everything related to a single conversation.</p>"},{"location":"chat-uui/01_thread/#what-problem-does-the-thread-solve","title":"What Problem Does the Thread Solve?","text":"<p>Let's say a user asks your chatbot, \"What's the weather like today?\". The chatbot replies, \"It's sunny and 25\u00b0C\".  You need to display both of these messages in a way that's easy to read and follow.  You also need a place for the user to type their next question. The <code>Thread</code> handles all of this. It's the container for the entire back-and-forth.</p>"},{"location":"chat-uui/01_thread/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Displaying Messages: The <code>Thread</code> is responsible for showing the messages in the chat, whether they're from the user or the chatbot.</p> </li> <li> <p>Managing Conversation Flow:  It keeps track of the order of messages and handles things like scrolling and displaying new messages as they arrive.</p> </li> <li> <p>User Input: The <code>Thread</code> includes the text input area (we'll cover this more in the Composer chapter) where the user types their messages.</p> </li> </ol>"},{"location":"chat-uui/01_thread/#using-the-thread","title":"Using the Thread","text":"<p>Here\u2019s a simplified snippet showing how the <code>Thread</code> is used:</p> <pre><code>import { ThreadPrimitive } from \"@assistant-ui/react\";\n\nfunction MyChatbot() {\n  return (\n    &lt;ThreadPrimitive.Root&gt;\n      &lt;ThreadPrimitive.Viewport&gt;\n        {/* Place to display messages */}\n        &lt;ThreadPrimitive.Messages /&gt; \n\n        {/* Input area for user */}\n        &lt;Composer /&gt; \n      &lt;/ThreadPrimitive.Viewport&gt;\n    &lt;/ThreadPrimitive.Root&gt;\n  );\n}\n</code></pre> <p>This code creates a basic <code>Thread</code>.  <code>ThreadPrimitive.Root</code> is the main container. <code>ThreadPrimitive.Viewport</code> is the area where messages are displayed. <code>ThreadPrimitive.Messages</code> is responsible for rendering the actual Message components (we\u2019ll learn about those in the next chapter!).  The <code>&lt;Composer /&gt;</code> component (covered in the Composer chapter) is where the user types their messages.</p>"},{"location":"chat-uui/01_thread/#under-the-hood","title":"Under the Hood","text":"<p>When a user sends a message:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Composer\n    participant Thread\n    participant Runtime\n    participant Assistant\n\n    User-&gt;&gt;Composer: Types a message and presses enter\n    Composer-&gt;&gt;Thread: Sends the message\n    Thread-&gt;&gt;Runtime: Passes the message to the runtime\n    Runtime-&gt;&gt;Assistant: Sends the message to the assistant\n    Assistant-&gt;&gt;Runtime: Returns a response\n    Runtime-&gt;&gt;Thread: Sends the response back\n    Thread-&gt;&gt;Viewport: Displays the response\n</code></pre> <p>The <code>Thread</code> acts as a central hub, receiving messages from the user via the Composer, passing them to the Runtime, and then displaying the responses it receives back.  Think of it like a post office, routing messages between the user and the assistant.</p> <p>The <code>ThreadPrimitive.Messages</code> component uses the message data provided by the Runtime to display the conversation history. It automatically handles rendering different message types (user messages, assistant messages, etc.).</p>"},{"location":"chat-uui/01_thread/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<pre><code>// ... inside ThreadPrimitive.Messages\nmessages.map((message) =&gt; {\n  if (message.role === \"user\") {\n    return &lt;UserMessage /&gt;; // Display user message\n  } else if (message.role === \"assistant\") {\n    return &lt;AssistantMessage /&gt;; // Display assistant message\n  }\n  // ... handling other message types\n});\n</code></pre> <p>This simplified code shows how <code>ThreadPrimitive.Messages</code> iterates through the messages and renders the appropriate components for each one.</p>"},{"location":"chat-uui/01_thread/#conclusion","title":"Conclusion","text":"<p>The <code>Thread</code> component provides the foundation for building a conversational interface. It manages the display of messages, handles user input, and connects to the Runtime to send and receive messages. In the next chapter, we'll explore the Message component, which represents individual messages within the thread.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/02_message/","title":"Chapter 2: Message","text":"<p>In the previous chapter, Thread, we learned how the <code>Thread</code> component acts as the main container for our chatbot conversation. Now, let's zoom in and explore the individual building blocks of that conversation: the <code>Message</code> component.</p>"},{"location":"chat-uui/02_message/#what-problem-does-the-message-solve","title":"What Problem Does the Message Solve?","text":"<p>Imagine our chatbot tells the user, \"The weather in London is 20\u00b0C and cloudy.\"  This entire sentence is a single unit of communication \u2013 a single message. The <code>Message</code> component represents this single unit. It holds the actual text (\"The weather\u2026cloudy.\") and any other information related to it, like who sent it (the chatbot) and when it was sent.</p>"},{"location":"chat-uui/02_message/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Content:  The most important part! This is the actual information being communicated.  It can be simple text, images, files, or even audio. Think of the content as the \"body\" of an email.</p> </li> <li> <p>Metadata: Extra information about the message. This includes who sent the message (user or assistant), the timestamp, and any other relevant details.  Think of metadata as the \"header\" of an email (sender, date, etc.).</p> </li> </ol>"},{"location":"chat-uui/02_message/#using-the-message","title":"Using the Message","text":"<p>The <code>Message</code> component itself isn't something you directly create.  It's handled within the <code>Thread</code>. The <code>ThreadPrimitive.Messages</code> component automatically creates and displays <code>Message</code> components based on the data from the Runtime.</p> <pre><code>import { ThreadPrimitive } from \"@assistant-ui/react\";\n\n// ... inside the Thread component\n&lt;ThreadPrimitive.Messages \n  components={{\n    UserMessage: MyUserMessage, // Custom User Message component\n    AssistantMessage: MyAssistantMessage, // Custom Assistant Message component\n  }}\n/&gt;\n</code></pre> <p>Here, <code>ThreadPrimitive.Messages</code> is responsible for displaying the messages.  You can customize the look of user and assistant messages by providing your own <code>MyUserMessage</code> and <code>MyAssistantMessage</code> components.  These components will receive the individual <code>Message</code> data as props and can use <code>MessagePrimitive.Content</code> to access and display the content of the message.</p> <pre><code>import { MessagePrimitive } from \"@assistant-ui/react\";\n\nconst MyUserMessage = () =&gt; (\n  &lt;div&gt;\n    &lt;MessagePrimitive.Content /&gt; {/* Displays the message content */}\n  &lt;/div&gt;\n);\n\n\nconst MyAssistantMessage = () =&gt; (\n  &lt;div&gt;\n    &lt;MessagePrimitive.Content /&gt; {/* Displays the message content */}\n  &lt;/div&gt;\n);\n</code></pre>"},{"location":"chat-uui/02_message/#under-the-hood","title":"Under the Hood","text":"<p>Let's visualize how the <code>Message</code> data flows through the system:</p> <pre><code>sequenceDiagram\n    participant Runtime\n    participant Thread\n    participant Messages\n    participant Message\n\n    Runtime-&gt;&gt;Thread: Sends message data\n    Thread-&gt;&gt;Messages: Passes message data\n    Messages-&gt;&gt;Message: Creates Message component with data\n    Message-&gt;&gt;Content: Displays message content\n</code></pre>"},{"location":"chat-uui/02_message/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>ThreadPrimitive.Messages</code> component gets message data from the Runtime.  This data includes content and metadata.</p> <pre><code>// ... inside ThreadPrimitive.Messages (simplified)\nmessages.map((messageData) =&gt; (\n  &lt;Message \n    key={messageData.id} \n    role={messageData.role} // e.g., \"user\" or \"assistant\"\n    createdAt={messageData.createdAt} // Timestamp\n    // ... other metadata\n  &gt;\n    { /* Your custom Message component receives messageData as props */}\n      &lt;MessagePrimitive.Content /&gt; {/* Your custom Message component uses MessagePrimitive.Content to display the actual content from messageData */}\n  &lt;/Message&gt;\n));\n</code></pre> <p><code>MessagePrimitive.Content</code> then renders the actual content of the message, which might be text, images, etc. (Content Part chapter explains more about handling different content types).</p>"},{"location":"chat-uui/02_message/#conclusion","title":"Conclusion","text":"<p>The <code>Message</code> component is a fundamental piece of <code>chat-uui</code>.  It represents a single communication unit within the Thread, holding the message content and associated metadata. We can use <code>MessagePrimitive.Content</code> within our custom <code>Message</code> components to display this content. Next, we'll look at how the user types messages using the Composer.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/03_composer/","title":"Chapter 3: Composer","text":"<p>In the previous chapter, Message, we learned how individual messages are represented. But how does the user actually create those messages? That's where the <code>Composer</code> comes in.</p>"},{"location":"chat-uui/03_composer/#what-problem-does-the-composer-solve","title":"What Problem Does the Composer Solve?","text":"<p>Imagine you're using a messaging app.  You type your message in a text box at the bottom of the screen. This text box, along with the send button (and sometimes options for adding attachments), is exactly what the <code>Composer</code> represents in <code>chat-uui</code>. It provides the interface for the user to compose and send messages to the assistant.</p>"},{"location":"chat-uui/03_composer/#key-concepts","title":"Key Concepts","text":"<ol> <li>Input Area:  The text box itself where you type your message.</li> <li>Send Button: The button you click to send your message.</li> <li>Attachments (Optional): Functionality to add images, files, etc., to your message.</li> </ol>"},{"location":"chat-uui/03_composer/#using-the-composer","title":"Using the Composer","text":"<p>The <code>Composer</code> is placed within the Thread component's viewport. Here's a simplified example:</p> <pre><code>import { ComposerPrimitive } from \"@assistant-ui/react\";\n\n// ... inside the Thread component\n&lt;ComposerPrimitive.Root&gt;\n  &lt;ComposerPrimitive.Input placeholder=\"Write a message...\" /&gt;\n  &lt;ComposerPrimitive.Send /&gt; {/* The Send button */}\n&lt;/ComposerPrimitive.Root&gt;\n</code></pre> <p>This code creates a basic <code>Composer</code>. <code>ComposerPrimitive.Root</code> acts as the container. <code>ComposerPrimitive.Input</code> provides the text input area.  <code>ComposerPrimitive.Send</code> renders the send button.</p>"},{"location":"chat-uui/03_composer/#under-the-hood","title":"Under the Hood","text":"<p>When a user types a message and clicks send:</p> <pre><code>sequenceDiagram\n    participant User\n    participant ComposerInput\n    participant ComposerSend\n    participant Thread\n    participant Runtime\n\n    User-&gt;&gt;ComposerInput: Types a message\n    User-&gt;&gt;ComposerSend: Clicks Send\n    ComposerSend-&gt;&gt;ComposerRoot: Submits the form\n    ComposerRoot-&gt;&gt;Thread: Sends the message\n    Thread-&gt;&gt;Runtime: Passes the message to the runtime\n</code></pre> <p><code>ComposerPrimitive.Input</code> captures the user's text. When the user clicks <code>ComposerPrimitive.Send</code>, it triggers a form submission (handled by <code>ComposerPrimitive.Root</code>). This form submission then sends the message up to the Thread, which passes it on to the Runtime.</p>"},{"location":"chat-uui/03_composer/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<pre><code>// ... inside ComposerPrimitive.Root\nfunction handleSubmit(e: FormEvent) {\n  e.preventDefault(); // Prevent default browser form submission\n  // ... get the text from ComposerPrimitive.Input\n  // ... send the message to the Thread\n}\n\n&lt;form onSubmit={handleSubmit}&gt;\n  {/* ... ComposerPrimitive.Input and ComposerPrimitive.Send are placed here */}\n&lt;/form&gt;\n</code></pre> <p>The <code>ComposerPrimitive.Root</code> component is internally a <code>&lt;form&gt;</code> element. It handles the form submission and sends the message to the thread. <code>ComposerPrimitive.Send</code> triggers this submission.  The implementation details of sending the message to the Thread are handled within <code>chat-uui</code>.</p>"},{"location":"chat-uui/03_composer/#adding-attachments-advanced","title":"Adding Attachments (Advanced)","text":"<p>You can also add attachments using <code>ComposerPrimitive.Attachments</code> and <code>ComposerPrimitive.AddAttachment</code>:</p> <pre><code>import { ComposerPrimitive } from \"@assistant-ui/react\";\n\n&lt;ComposerPrimitive.Root&gt;\n  &lt;ComposerPrimitive.Attachments /&gt; {/* Display attachments */}\n  &lt;ComposerPrimitive.AddAttachment /&gt; {/* Button to add attachments */}\n  &lt;ComposerPrimitive.Input placeholder=\"Write a message...\" /&gt;\n  &lt;ComposerPrimitive.Send /&gt;\n&lt;/ComposerPrimitive.Root&gt;\n</code></pre> <p><code>ComposerPrimitive.AddAttachment</code> provides a button that opens a file picker.  <code>ComposerPrimitive.Attachments</code> renders the selected attachments. More details about attachments will be covered in the Content Part chapter.</p>"},{"location":"chat-uui/03_composer/#conclusion","title":"Conclusion","text":"<p>The <code>Composer</code> component provides the essential input area for users to interact with the assistant. It handles text input, sending messages, and optionally, managing attachments.  Now that we know how users send messages, let's explore the different types of content a message can contain in the next chapter, Content Part.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/04_content_part/","title":"Chapter 4: Content Part","text":"<p>In the previous chapter, Composer, we learned how users type and send messages.  Now, let's look inside a Message and explore its different parts: <code>Content Part</code>s.</p>"},{"location":"chat-uui/04_content_part/#what-problem-does-a-content-part-solve","title":"What Problem Does a Content Part Solve?","text":"<p>Imagine your chatbot wants to send a message containing an image and some text, like \"Here's a picture of a sunny day! \u2600\ufe0f The temperature is 25\u00b0C.\"  A single <code>Content Part</code> can't handle both. You need separate <code>Content Part</code>s for the image and the text.  <code>Content Part</code>s allow a Message to contain different types of content, making messages richer and more interactive.</p>"},{"location":"chat-uui/04_content_part/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Different Types: <code>Content Part</code>s can represent various content types, including text, images, files, and even interactive elements like buttons or tool calls. Think of them like different building blocks for your message.</p> </li> <li> <p>Combined in a Message:  A single Message can contain multiple <code>Content Part</code>s.  This is like building a house with different materials: bricks, wood, glass, etc.</p> </li> </ol>"},{"location":"chat-uui/04_content_part/#using-content-parts","title":"Using Content Parts","text":"<p>You don't directly create <code>Content Part</code> components.  The <code>MessagePrimitive.Content</code> component within your custom Message components will handle rendering the correct <code>Content Part</code> based on the data received from the Runtime.</p> <pre><code>import { MessagePrimitive } from \"@assistant-ui/react\";\n\nconst MyAssistantMessage = ({ message }) =&gt; (\n  &lt;div&gt;\n    &lt;MessagePrimitive.Content /&gt; {/* Renders Content Parts */}\n  &lt;/div&gt;\n);\n</code></pre> <p>You can customize how each type of <code>Content Part</code> is rendered by passing custom components to <code>MessagePrimitive.Content</code>.</p> <pre><code>import { MessagePrimitive } from \"@assistant-ui/react\";\n\nconst MyImageComponent = ({ src }) =&gt; &lt;img src={src} alt=\"Image\" /&gt;;\n\nconst MyAssistantMessage = ({ message }) =&gt; (\n  &lt;div&gt;\n    &lt;MessagePrimitive.Content components={{ Image: MyImageComponent }} /&gt;\n  &lt;/div&gt;\n);\n</code></pre> <p>This example uses a custom <code>MyImageComponent</code> to render image <code>Content Part</code>s.</p>"},{"location":"chat-uui/04_content_part/#under-the-hood","title":"Under the Hood","text":"<p>Let's see how the <code>Content Part</code>s are processed and displayed:</p> <pre><code>sequenceDiagram\n    participant Runtime\n    participant Thread\n    participant Message\n    participant MessageContent\n    participant ContentPart\n\n    Runtime-&gt;&gt;Thread: Sends message data (including content parts)\n    Thread-&gt;&gt;Message: Passes message data to the Message component\n    Message-&gt;&gt;MessageContent: Calls MessagePrimitive.Content\n    MessageContent-&gt;&gt;ContentPart: Renders individual Content Part components based on type (text, image, etc.)\n</code></pre>"},{"location":"chat-uui/04_content_part/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>MessagePrimitive.Content</code> component receives an array of <code>Content Part</code> data from the Runtime via the Message component.  It then iterates through this array and renders the appropriate component for each <code>Content Part</code>.</p> <pre><code>// ... inside MessagePrimitive.Content (simplified - see packages/react/src/primitives/message/MessageContent.tsx)\nmessage.content.map((part) =&gt; {\n  switch (part.type) {\n    case \"text\":\n      return &lt;TextContentPartComponent {...part} /&gt;;\n    case \"image\":\n      return &lt;ImageContentPartComponent {...part} /&gt;;\n    // ... other content part types\n  }\n});\n</code></pre> <p>The specific components for each type (<code>TextContentPartComponent</code>, <code>ImageContentPartComponent</code>, etc.) can be customized as shown in the \"Using Content Parts\" section.</p>"},{"location":"chat-uui/04_content_part/#conclusion","title":"Conclusion","text":"<p><code>Content Part</code>s enable rich and dynamic messages by allowing different content types within a single Message. <code>MessagePrimitive.Content</code> handles the rendering of these parts, providing flexibility in how they are displayed.  In the next chapter, we'll explore the Runtime, which manages the communication between the user interface and the assistant.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/05_runtime/","title":"Chapter 5: Runtime","text":"<p>In the last chapter, Content Part, we explored the different types of content that can make up a Message. Now, let's learn about the <code>Runtime</code>, the engine that makes the whole chat interface work.</p>"},{"location":"chat-uui/05_runtime/#what-problem-does-the-runtime-solve","title":"What Problem Does the Runtime Solve?","text":"<p>Imagine you type a message into the Composer of your chatbot and hit send.  Your message is just text.  The AI model, however, needs that text in a specific format to understand it. The <code>Runtime</code> acts like a translator, converting your message into the language the AI understands and then converting the AI's response back into text (or other Content Parts) that you can see in the Thread. It also handles sending and receiving messages, making sure the conversation flows smoothly.</p>"},{"location":"chat-uui/05_runtime/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Translator:  Converts messages between the user interface (Composer, Thread) and the backend (AI model).</p> </li> <li> <p>Messenger:  Sends the translated messages to the AI and receives its responses.</p> </li> <li> <p>Orchestrator:  Manages the entire process, handling message flow, loading indicators, and error handling.</p> </li> </ol>"},{"location":"chat-uui/05_runtime/#using-the-runtime","title":"Using the Runtime","text":"<p>You don't directly interact with the <code>Runtime</code> methods like <code>send</code> or <code>receive</code>.  <code>chat-uui</code> components like the Composer and Thread use the <code>Runtime</code> under the hood. You primarily interact with it by providing it when you set up your application.</p> <pre><code>import { AssistantRuntimeProvider } from \"@assistant-ui/react\";\nimport { useChatRuntime } from \"@assistant-ui/react-ai-sdk\";\n\n// ... inside your main app component\nconst runtime = useChatRuntime({ api: \"/api/chat\" });\n\nreturn (\n  &lt;AssistantRuntimeProvider runtime={runtime}&gt;\n    {/* Your chat interface components */}\n  &lt;/AssistantRuntimeProvider&gt;\n);\n</code></pre> <p>This code sets up the <code>Runtime</code> using <code>useChatRuntime</code> (which handles communication with your backend API at <code>/api/chat</code>) and makes it available to your entire chat interface via the <code>AssistantRuntimeProvider</code>.  This provider acts like a context, so all child components can access the runtime automatically.</p>"},{"location":"chat-uui/05_runtime/#under-the-hood","title":"Under the Hood","text":"<p>Let's visualize what happens when you send a message:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Composer\n    participant Thread\n    participant Runtime\n    participant Backend\n\n    User-&gt;&gt;Composer: Types and sends a message\n    Composer-&gt;&gt;Thread: Submits the message\n    Thread-&gt;&gt;Runtime: Calls the \"send\" method with the message\n    Runtime-&gt;&gt;Backend: Sends the formatted message to the backend API\n    Backend-&gt;&gt;Runtime: Returns the AI's response\n    Runtime-&gt;&gt;Thread: Delivers the formatted response\n    Thread-&gt;&gt;Message: Displays the response\n</code></pre>"},{"location":"chat-uui/05_runtime/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>Runtime</code> uses an adapter (like <code>useChatRuntime</code> in the example above) to handle the actual communication with your specific backend.</p> <pre><code>// ... inside useChatRuntime (simplified - see packages/react-ai-sdk/src/useChatRuntime.ts)\nconst runtime = useEdgeRuntime({ \n  // ... options to configure the adapter\n  unstable_AISDKInterop: \"v2\",\n});\n\n// ... returns the configured runtime \n</code></pre> <p>The <code>useEdgeRuntime</code> function sets up the low-level communication, including formatting the messages and handling the API calls.  The details of the adapter implementation are abstracted away, allowing you to easily switch between different backends without changing your core UI code.</p> <p>The <code>AssistantRuntimeProvider</code> makes the runtime available to other components:</p> <pre><code>// ... inside AssistantRuntimeProvider (simplified - see packages/react/src/context/providers/AssistantRuntimeProvider.tsx)\n&lt;AssistantContext.Provider value={{ useAssistantRuntime }}&gt;\n  {/* Your chat interface components */}\n&lt;/AssistantContext.Provider&gt;\n</code></pre>"},{"location":"chat-uui/05_runtime/#conclusion","title":"Conclusion","text":"<p>The <code>Runtime</code> acts as the essential bridge between your chat interface and the AI backend. It handles message translation, sending, receiving, and overall orchestration of the conversation.  By providing this runtime using <code>AssistantRuntimeProvider</code>, you seamlessly connect all the pieces of your chatbot.  Next, we'll learn how to use <code>chat-uui</code> with Assistant Cloud, a convenient backend service.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/06_assistant_cloud/","title":"Chapter 6: Assistant Cloud","text":"<p>In the previous chapter, Runtime, we learned how the <code>Runtime</code> manages communication between our chat interface and the AI backend.  This chapter introduces <code>Assistant Cloud</code>, a service that simplifies building the backend itself.</p>"},{"location":"chat-uui/06_assistant_cloud/#what-problem-does-assistant-cloud-solve","title":"What Problem Does Assistant Cloud Solve?","text":"<p>Imagine you're building a chatbot where users can ask questions about their order history.  You want to save these conversations so users can refer back to them later. Building a backend to store, manage, and retrieve these chat logs can be complex and time-consuming.  <code>Assistant Cloud</code> provides a ready-made solution for this \u2013 a cloud-based storage system specifically designed for chat history and analytics.  Think of it as a specialized database for your chatbot conversations.</p>"},{"location":"chat-uui/06_assistant_cloud/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Persistence: <code>Assistant Cloud</code> stores your chat data (messages, threads, etc.) so it's available even after the user closes the browser or the application restarts.  This is like saving a document to your hard drive.</p> </li> <li> <p>Management:  It provides tools to organize and manage your chat data, including searching, filtering, and retrieving conversations.  This is like using a file manager to organize your documents.</p> </li> <li> <p>Analytics (Future): <code>Assistant Cloud</code> is designed to support future analytics features, allowing you to gain insights from your chat data. This could include things like identifying common user questions or tracking chatbot performance.</p> </li> </ol>"},{"location":"chat-uui/06_assistant_cloud/#using-assistant-cloud","title":"Using Assistant Cloud","text":"<p>First, you need to create an instance of <code>AssistantCloud</code>:</p> <pre><code>import { AssistantCloud } from \"@assistant-ui/react\";\n\nconst cloud = new AssistantCloud({\n  baseUrl: process.env[\"NEXT_PUBLIC_ASSISTANT_BASE_URL\"]!,\n  anonymous: true, // For testing purposes. Replace with proper authentication in a real application.\n});\n</code></pre> <p>This code initializes <code>AssistantCloud</code> with a base URL (where your cloud instance is hosted) and sets up anonymous authentication for simplicity.  In a real application, you would use proper authentication methods (like API keys or JWT tokens).</p> <p>Next, you connect <code>Assistant Cloud</code> to your Runtime:</p> <pre><code>import { useChatRuntime } from \"@assistant-ui/react-ai-sdk\";\n\nconst runtime = useChatRuntime({\n  cloud, // Connect the cloud instance\n  api: \"/api/chat\", // Your API endpoint (if applicable)\n});\n</code></pre> <p>By providing the <code>cloud</code> instance to <code>useChatRuntime</code>, you tell the Runtime to use <code>Assistant Cloud</code> for storing and retrieving messages.</p> <p>Now, when a user sends a message through the Composer, the Runtime will automatically save the message to <code>Assistant Cloud</code>. The Thread will also load messages from <code>Assistant Cloud</code> when it initializes.</p>"},{"location":"chat-uui/06_assistant_cloud/#under-the-hood","title":"Under the Hood","text":"<p>Here's a simplified sequence diagram showing how <code>Assistant Cloud</code> interacts with other components when a message is sent:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Composer\n    participant Runtime\n    participant Assistant Cloud\n\n    User-&gt;&gt;Composer: Types and sends a message\n    Composer-&gt;&gt;Runtime: Submits the message\n    Runtime-&gt;&gt;Assistant Cloud: Stores the message\n    Runtime-&gt;&gt;Assistant: Sends the message for processing (if applicable)\n</code></pre>"},{"location":"chat-uui/06_assistant_cloud/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>useChatRuntime</code> internally uses an adapter to interact with <code>Assistant Cloud</code>:</p> <p><pre><code>// ... inside useChatRuntime (simplified)\nconst threadHistoryAdapter = useAssistantCloudThreadHistoryAdapter(cloudRef);\n\nconst runtime = useEdgeRuntime({\n  unstable_AISDKInterop: \"v2\",\n  // ...other options\n  messageRepository: createMessageRepository(threadHistoryAdapter),\n});\n</code></pre> The <code>useAssistantCloudThreadHistoryAdapter</code> creates an adapter that handles communication between the Runtime's message repository and <code>Assistant Cloud</code>.</p> <p>This adapter uses methods from <code>AssistantCloud</code> to store and retrieve messages:</p> <pre><code>// ... inside AssistantCloudThreadHistoryAdapter (simplified - see packages/react/src/cloud/AssistantCloudThreadHistoryAdapter.tsx)\nasync append(messageData) {\n  // ...\n  this.cloudRef.current.threads.messages.create(threadId, {\n    // ... message data\n  });\n}\n\nasync load() {\n  // ...\n  const { messages } = await this.cloudRef.current.threads.messages.list(threadId);\n  // ... process messages\n}\n</code></pre> <p>The <code>create</code> method saves a new message, and the <code>list</code> method retrieves existing messages for a given thread.  These methods communicate with the <code>Assistant Cloud</code> API to perform the actual storage and retrieval operations.</p>"},{"location":"chat-uui/06_assistant_cloud/#conclusion","title":"Conclusion","text":"<p><code>Assistant Cloud</code> provides a convenient way to manage your chat history without building your own backend.  By connecting it to your Runtime, you can easily persist, manage, and (in the future) analyze your chat data. In the next chapter, we'll learn about Model Context and how to provide additional information to the AI model.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/07_model_context/","title":"Chapter 7: Model Context","text":"<p>In the previous chapter, Assistant Cloud, we learned how to store and retrieve chat history.  Now, let's explore how to give the AI more information to tailor its responses \u2013 using <code>Model Context</code>.</p>"},{"location":"chat-uui/07_model_context/#what-problem-does-model-context-solve","title":"What Problem Does Model Context Solve?","text":"<p>Imagine you're building a chatbot for a pizza restaurant.  A user asks, \"Can I get a large pepperoni pizza?\".  Without any extra information, the AI might just say \"Sure!\". But what if you want the AI to automatically add the pizza to the user's online order?  <code>Model Context</code> lets you provide details like the user's current order, their location, and even special instructions like allergies, enabling the AI to provide more helpful and personalized responses.</p>"},{"location":"chat-uui/07_model_context/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Instructions: Think of <code>Model Context</code> as instructions for a chef.  You're providing the AI with the background information it needs to \"cook up\" the right response.</p> </li> <li> <p>Parameters:  These instructions include things like \"temperature\" (how creative the AI should be), \"system message\" (the overall tone and personality), and \"tools\" (actions the AI can perform, like adding a pizza to an order).</p> </li> </ol>"},{"location":"chat-uui/07_model_context/#using-model-context","title":"Using Model Context","text":"<p>You provide <code>Model Context</code> to the Runtime using <code>registerModelContextProvider</code>.  Here's a simplified example:</p> <pre><code>import { useAssistantRuntime } from \"@assistant-ui/react\";\n\nconst runtime = useAssistantRuntime();\n\nruntime.registerModelContextProvider({\n  getModelContext: () =&gt; ({\n    system: \"You are a helpful chatbot for a pizza restaurant.\",\n    // ... other context information\n  }),\n});\n</code></pre> <p>This code sets the <code>system</code> message to instruct the AI to act like a pizza restaurant chatbot.  Let's add user-specific information, like their current order:</p> <p><pre><code>runtime.registerModelContextProvider({\n  getModelContext: () =&gt; ({\n    system: \"You are a helpful chatbot for a pizza restaurant.\",\n    tools: {\n      add_to_order: { /* ... tool definition ... */ } // We'll cover tools in the next chapter\n    },\n      userOrder: { \n      items: [\"1 large soda\"],\n    },\n  }),\n});\n</code></pre> Now the AI has access to the user's order (currently containing one large soda) within its <code>Model Context</code>, allowing it to provide relevant responses like \"Sure! I've added a large pepperoni pizza to your order, which now includes one large soda and one large pepperoni pizza.\"</p>"},{"location":"chat-uui/07_model_context/#under-the-hood","title":"Under the Hood","text":"<p>When the user sends a message:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Composer\n    participant Runtime\n    participant Model Context Provider\n    participant AI Model\n\n    User-&gt;&gt;Composer: Sends message \"Can I get a large pepperoni pizza?\"\n    Composer-&gt;&gt;Runtime: Submits message\n    Runtime-&gt;&gt;Model Context Provider: Requests Model Context\n    Model Context Provider-&gt;&gt;Runtime: Provides Model Context (system message, userOrder, etc.)\n    Runtime-&gt;&gt;AI Model: Sends message and Model Context\n    AI Model-&gt;&gt;Runtime: Returns response\n</code></pre> <p>The Runtime gathers the <code>Model Context</code> from all registered providers and sends it along with the user's message to the AI model.</p>"},{"location":"chat-uui/07_model_context/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>registerModelContextProvider</code> method adds a provider to a set within the runtime:</p> <pre><code>// ... inside useAssistantRuntime (simplified - see packages/react/src/context/hooks/useAssistantRuntime.ts)\nconst registerModelContextProvider = (provider: ModelContextProvider) =&gt; {\n    configSet.add(provider);\n  // ... notify subscribers of change\n};\n</code></pre> <p>The <code>mergeModelContexts</code> function then combines all contexts from these providers:</p> <pre><code>// ... inside mergeModelContexts (simplified - see packages/react/src/model-context/ModelContextTypes.ts)\nexport const mergeModelContexts = (\n  configSet: Set&lt;ModelContextProvider&gt;,\n): ModelContext =&gt; {\n  const configs = Array.from(configSet).map((c) =&gt; c.getModelContext());\n\n  return configs.reduce((acc, config) =&gt; {\n    // ... merge system messages, tools, etc.\n  }, {} as ModelContext);\n};\n</code></pre> <p>This merged <code>Model Context</code> is then sent to the AI model.</p>"},{"location":"chat-uui/07_model_context/#conclusion","title":"Conclusion","text":"<p><code>Model Context</code> empowers you to give the AI the information it needs to generate relevant and personalized responses. By providing instructions and parameters, you can shape the AI's behavior and enable it to interact with your application's data.  In the next chapter, Tools and Tool UI, we'll explore how to give the AI the ability to take actions, like adding that pizza to the user's order.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/08_tools_and_tool_ui/","title":"Chapter 8: Tools and Tool UI","text":"<p>In the previous chapter, Model Context, we learned how to provide background information to the AI.  Now, let's explore how to empower the AI to take actions and interact with your application using Tools and display the results visually with Tool UI.</p>"},{"location":"chat-uui/08_tools_and_tool_ui/#what-problem-do-tools-and-tool-ui-solve","title":"What Problem Do Tools and Tool UI Solve?","text":"<p>Imagine you're building a chatbot for a weather app.  A user asks, \"What's the weather in Tokyo?\".  You want the AI to fetch the latest weather data from a weather API. A Tool is like giving the AI a special button it can press to call that API.  The Tool UI then displays the results of that API call, like the temperature and a sunny icon, directly within the chat.</p>"},{"location":"chat-uui/08_tools_and_tool_ui/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Tools: These are functions that the AI can call.  They perform actions or retrieve information, like searching the web, getting the current time, or updating a database. Think of them as the AI's \"helpers\".</p> </li> <li> <p>Tool UI: These are components that display the results of the Tool calls in the chat interface. They provide a visual representation of the AI's actions, making the conversation more interactive and informative.  Think of them as the AI's \"reports\".</p> </li> </ol>"},{"location":"chat-uui/08_tools_and_tool_ui/#using-tools-and-tool-ui","title":"Using Tools and Tool UI","text":"<p>Let's create a simple \"get_weather\" tool:</p> <pre><code>import { useAssistantTool, tool } from \"@assistant-ui/react\";\nimport { z } from \"zod\";\n\nconst get_weather = tool({\n  toolName: \"get_weather\",\n  parameters: z.object({ location: z.string() }),\n  execute: async ({ location }) =&gt; {\n    // ... call weather API here ...\n    const weatherData = { temperature: \"25\u00b0C\", condition: \"sunny\" }; // Dummy data\n    return weatherData;\n  },\n});\n\n\nuseAssistantTool(get_weather);\n</code></pre> <p>This code defines a tool named <code>get_weather</code> that takes a <code>location</code> parameter. The <code>execute</code> function simulates calling a weather API and returns dummy data.  <code>useAssistantTool</code> registers the tool with the Runtime, making it available to the AI.</p> <p>Now, let's create the Tool UI to display the weather data:</p> <pre><code>import { makeAssistantToolUI } from \"@assistant-ui/react\";\n\nconst WeatherToolUI = makeAssistantToolUI({\n  toolName: \"get_weather\",\n  render: ({ result }) =&gt; {\n    if (!result) return null; // Handle loading state\n    return (\n      &lt;div&gt;\n        Temperature: {result.temperature}, Condition: {result.condition}\n      &lt;/div&gt;\n    );\n  },\n});\n\n// ... within your app\n&lt;WeatherToolUI /&gt;\n</code></pre> <p><code>makeAssistantToolUI</code> creates the Tool UI component. The <code>render</code> function receives the <code>result</code> of the tool call (the <code>weatherData</code> in our example) and displays it in a div.  We also handle the loading state by returning <code>null</code> when the result is not yet available. Place this Tool UI component within the main app as a sibling of Thread component like the example above.</p>"},{"location":"chat-uui/08_tools_and_tool_ui/#under-the-hood","title":"Under the Hood","text":"<p>When the AI calls the <code>get_weather</code> tool:</p> <pre><code>sequenceDiagram\n    participant AI\n    participant Runtime\n    participant Tool\n    participant Tool UI\n\n    AI-&gt;&gt;Runtime: Calls \"get_weather\" with location \"Tokyo\"\n    Runtime-&gt;&gt;Tool: Executes the tool function\n    Tool-&gt;&gt;Runtime: Returns weather data\n    Runtime-&gt;&gt;Tool UI: Passes the weather data\n    Tool UI-&gt;&gt;Thread: Displays the weather data in a card\n</code></pre>"},{"location":"chat-uui/08_tools_and_tool_ui/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>useAssistantTool</code> function registers the tool with the Runtime:</p> <pre><code>// ... inside useAssistantTool (simplified)\nuseEffect(() =&gt; {\n  // ... registers the tool with the runtime\n}, [tool]); // Re-registers if the tool changes\n</code></pre> <p><code>makeAssistantToolUI</code> stores the render function for the given tool name:</p> <pre><code>// ... inside makeAssistantToolUI (simplified)\nconst Component: AssistantToolUI = () =&gt; null;\nComponent.unstable_toolUI = {\n  toolName,\n  render,\n};\nreturn Component;\n</code></pre> <p>The <code>MessagePrimitive.Content</code> component in the Message then uses this render function when it encounters a tool call:</p> <pre><code>// ... inside MessagePrimitive.Content (simplified)\nif (part.type === \"tool-call\") {\n  const ToolUI = getToolUI(part.toolName); // Retrieves the render function\n  return &lt;ToolUI {...part} /&gt;; // Renders the Tool UI\n}\n</code></pre>"},{"location":"chat-uui/08_tools_and_tool_ui/#conclusion","title":"Conclusion","text":"<p>Tools and Tool UI allow the AI to interact with your application and display the results visually in the chat. This enables richer and more interactive conversations. In the next chapter, Markdown Text, we will discuss how to format text using Markdown.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/09_markdown_text/","title":"Chapter 9: Markdown Text","text":"<p>In the previous chapter, Tools and Tool UI, we learned how to give the AI the power to perform actions.  This chapter focuses on making the chat messages themselves more expressive and readable using <code>Markdown Text</code>.</p>"},{"location":"chat-uui/09_markdown_text/#what-problem-does-markdown-text-solve","title":"What Problem Does Markdown Text Solve?","text":"<p>Imagine your chatbot wants to emphasize a word, create a list, or share a link.  Plain text isn't enough!  <code>Markdown Text</code> lets you easily add formatting like bold, italics, code blocks, and links to your chatbot's messages, just like a mini text editor.  This makes the information clearer and more engaging for the user.</p>"},{"location":"chat-uui/09_markdown_text/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Markdown: A simple way to format text using special symbols. For example, <code>**bold**</code> becomes bold, and <code>*italics*</code> becomes italics.</p> </li> <li> <p>Rendering: <code>Markdown Text</code> takes the Markdown-formatted text and converts it into styled HTML that can be displayed in the Message component.</p> </li> </ol>"},{"location":"chat-uui/09_markdown_text/#using-markdown-text","title":"Using Markdown Text","text":"<p>You use the <code>MarkdownTextPrimitive</code> component within your custom Message components to render Markdown-formatted text.</p> <pre><code>import { MarkdownTextPrimitive } from \"@assistant-ui/react-markdown\";\n\n// ... inside your custom AssistantMessage component\nconst MyAssistantMessage = ({ message }) =&gt; (\n  &lt;div&gt;\n    &lt;MarkdownTextPrimitive value={message.content[0].text} /&gt; \n  &lt;/div&gt;\n);\n</code></pre> <p>In this simplified example, we assume the message content is a single text Content Part containing Markdown. <code>message.content[0].text</code> would contain the raw Markdown string like \"Here's a link: Google\". The <code>MarkdownTextPrimitive</code> component will render this as: Here's a link: Google.</p>"},{"location":"chat-uui/09_markdown_text/#under-the-hood","title":"Under the Hood","text":"<p>Here's what happens when <code>MarkdownTextPrimitive</code> receives Markdown:</p> <pre><code>sequenceDiagram\n    participant Message\n    participant MarkdownText\n    participant MarkdownParser\n    participant HTMLRenderer\n\n    Message-&gt;&gt;MarkdownText: Provides Markdown text (\"**bold** text\")\n    MarkdownText-&gt;&gt;MarkdownParser: Parses the Markdown\n    MarkdownParser-&gt;&gt;MarkdownText: Returns an Abstract Syntax Tree (AST)\n    MarkdownText-&gt;&gt;HTMLRenderer: Renders the AST as HTML\n    HTMLRenderer-&gt;&gt;Message: Returns the styled HTML (&lt;p&gt;&lt;strong&gt;bold&lt;/strong&gt; text&lt;/p&gt;)\n</code></pre>"},{"location":"chat-uui/09_markdown_text/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p><code>MarkdownTextPrimitive</code> uses a Markdown parser (like <code>remarkable</code> or <code>react-markdown</code>) to convert the Markdown text into an Abstract Syntax Tree (AST). This AST represents the structure and formatting of the Markdown.  Then, it uses a renderer to convert this AST into HTML elements.</p> <pre><code>// ... inside MarkdownTextPrimitive (simplified - see packages/react-markdown/src/primitives/MarkdownText.tsx)\nconst html = useMemo(() =&gt; {\n  // ... use a Markdown parser to convert the value (Markdown text) to HTML\n}, [value, components, remarkPlugins, rehypePlugins]);\n\nreturn (\n  &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt; // Simplified\n);\n</code></pre> <p>The component then uses <code>dangerouslySetInnerHTML</code> to render the resulting HTML, displaying the styled text in the message.</p>"},{"location":"chat-uui/09_markdown_text/#conclusion","title":"Conclusion","text":"<p><code>Markdown Text</code> provides a simple yet powerful way to format messages, making them more engaging and easier to read.  By using <code>MarkdownTextPrimitive</code> within your Message components, you can easily incorporate rich text formatting into your chatbot's responses.  In the next chapter, Assistant Modal, we'll learn about a convenient way to present contextual information and tools to the user.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"chat-uui/10_assistant_modal/","title":"Chapter 10: Assistant Modal","text":"<p>In the previous chapter, Markdown Text, we learned how to format text within messages. Now, let's explore the <code>Assistant Modal</code>, a convenient way to contain the chat interface itself.</p>"},{"location":"chat-uui/10_assistant_modal/#what-problem-does-the-assistant-modal-solve","title":"What Problem Does the Assistant Modal Solve?","text":"<p>Imagine you have a website with a lot of content. You want to add a chatbot, but you don't want it to take up valuable screen space all the time. You want it to appear only when needed. The <code>Assistant Modal</code> is like a pop-up window specifically designed for chat.  It sits discreetly on your page and expands into a full chat window when clicked, providing a dedicated space for conversation without cluttering the main content.</p>"},{"location":"chat-uui/10_assistant_modal/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Container:  The <code>Assistant Modal</code> acts as a container for your entire chat interface, including the Thread, Composer, and all the messages.</p> </li> <li> <p>Trigger:  A small, clickable element (usually a button or icon) that opens the modal. Think of it like a doorbell for the chatbot.</p> </li> <li> <p>Content Area:  The area that expands to display the chat conversation. Think of it like the room where you talk to the chatbot.</p> </li> </ol>"},{"location":"chat-uui/10_assistant_modal/#using-the-assistant-modal","title":"Using the Assistant Modal","text":"<p>You can easily add an <code>Assistant Modal</code> to your application using <code>AssistantModalPrimitive</code>:</p> <pre><code>import { AssistantModalPrimitive } from \"@assistant-ui/react\";\n\n// ... inside your main app component\n&lt;AssistantModalPrimitive.Root&gt;\n  &lt;AssistantModalPrimitive.Anchor className=\"fixed bottom-4 right-4 size-11\"&gt;\n    &lt;AssistantModalPrimitive.Trigger asChild&gt;\n      &lt;button&gt;Open Chat&lt;/button&gt;\n    &lt;/AssistantModalPrimitive.Trigger&gt;\n  &lt;/AssistantModalPrimitive.Anchor&gt;\n  &lt;AssistantModalPrimitive.Content&gt;\n    &lt;Thread /&gt;\n  &lt;/AssistantModalPrimitive.Content&gt;\n&lt;/AssistantModalPrimitive.Root&gt;\n</code></pre> <p>This code creates a basic <code>Assistant Modal</code>.  <code>AssistantModalPrimitive.Root</code> is the main container. <code>AssistantModalPrimitive.Anchor</code> positions the trigger. <code>AssistantModalPrimitive.Trigger</code> defines the clickable element that opens the modal (in this case, a simple button). <code>AssistantModalPrimitive.Content</code> holds the content of the modal, which in our case, is the Thread component.</p>"},{"location":"chat-uui/10_assistant_modal/#under-the-hood","title":"Under the Hood","text":"<p>Here's how the components interact when you click the trigger:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Trigger\n    participant Root\n    participant Content\n\n    User-&gt;&gt;Trigger: Clicks the trigger button\n    Trigger-&gt;&gt;Root: Notifies the root component\n    Root-&gt;&gt;Content: Shows the content area (the Thread)\n</code></pre> <p>Clicking the <code>AssistantModalPrimitive.Trigger</code> tells the <code>AssistantModalPrimitive.Root</code> to show the <code>AssistantModalPrimitive.Content</code>, which contains our chat interface.</p>"},{"location":"chat-uui/10_assistant_modal/#internal-implementation-simplified","title":"Internal Implementation (Simplified)","text":"<p>The <code>AssistantModalPrimitive.Root</code> component uses Radix UI's Popover under the hood to manage the opening and closing of the modal:</p> <pre><code>// ... inside AssistantModalPrimitive.Root (simplified - see packages/react/src/primitives/assistantModal/AssistantModalRoot.tsx)\n&lt;PopoverPrimitive.Root\n  open={open}\n  onOpenChange={onOpenChange}\n  // ... other props\n&gt;\n  {/* ... children */}\n&lt;/PopoverPrimitive.Root&gt;\n</code></pre> <p>The <code>AssistantModalPrimitive.Trigger</code> and <code>AssistantModalPrimitive.Content</code> components are connected to this <code>PopoverPrimitive.Root</code> to handle the trigger and content areas respectively.</p> <pre><code>// ... inside AssistantModalPrimitive.Trigger (simplified - see packages/react/src/primitives/assistantModal/AssistantModalTrigger.tsx)\n&lt;PopoverPrimitive.Trigger \n  // ... props\n/&gt;\n\n// ... inside AssistantModalPrimitive.Content (simplified - see packages/react/src/primitives/assistantModal/AssistantModalContent.tsx)\n&lt;PopoverPrimitive.Content\n  // ... props\n/&gt;\n</code></pre> <p>The specific styling and positioning of the modal are controlled by the CSS classes you apply to the components.</p>"},{"location":"chat-uui/10_assistant_modal/#conclusion","title":"Conclusion","text":"<p>The <code>Assistant Modal</code> provides a user-friendly way to integrate a chat interface into your application without cluttering the main content.  It allows the chat to be readily available when needed and hidden when not in use, improving the overall user experience.  This concludes our tutorial on <code>chat-uui</code>'s core concepts. We hope this guide has been helpful in understanding how to build your own conversational interfaces.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/","title":"Tutorial: uui","text":"<p>This project manages automated communication sequences, similar to marketing campaigns.  A GoAI Campaign acts as a blueprint for outreach, with Campaign Steps defining individual actions like emails or calls.  Engage Sequences automate these communications, enrolling contacts and sending messages according to Sequence Steps.  The system tracks interactions as Sequence Events and stores message content as Sequence Step Content.</p>    flowchart TD     A --&gt; B  <p>Source Repository: None</p> <pre><code>    A0[\"GoAI Campaign\"]\n    A1[\"GoAI Campaign Step\"]\n    A2[\"GoAI Campaign Message\"]\n    A3[\"Engage Sequence\"]\n    A4[\"Engage Sequence Step\"]\n    A5[\"Engage Sequence Membership\"]\n    A6[\"Engage Sequence Event\"]\n    A7[\"Engage Sequence Step Content\"]\n    A8[\"Engage Sequence OAuth Credential\"]\n    A0 -- \"Has many\" --&gt; A1\n    A0 -- \"Has many\" --&gt; A2\n    A1 -- \"Belongs to\" --&gt; A0\n    A3 -- \"Has many\" --&gt; A4\n    A3 -- \"Has many\" --&gt; A5\n    A3 -- \"Has many\" --&gt; A8\n    A4 -- \"Belongs to\" --&gt; A3\n    A4 -- \"Has many\" --&gt; A7\n    A5 -- \"Belongs to\" --&gt; A3\n    A5 -- \"Has current\" --&gt; A4\n    A5 -- \"Has many\" --&gt; A6\n    A6 -- \"Belongs to\" --&gt; A5\n    A7 -- \"Belongs to\" --&gt; A4\n    A8 -- \"Belongs to\" --&gt; A3\n    A4 -- \"Has many\" --&gt; A6\n</code></pre>"},{"location":"uui/#chapters","title":"Chapters","text":"<ol> <li>GoAI Campaign</li> <li>GoAI Campaign Step</li> <li>GoAI Campaign Message</li> <li>Engage Sequence</li> <li>Engage Sequence Step</li> <li>Engage Sequence Step Content</li> <li>Engage Sequence Membership</li> <li>Engage Sequence Event</li> <li>Engage Sequence OAuth Credential</li> </ol> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/01_goai_campaign/","title":"Chapter 1: GoAI Campaign","text":"<p>Imagine you're planning a marketing campaign. You want to reach out to hundreds of potential customers with a personalized message, but doing it manually would take forever.  That's where a GoAI Campaign comes in. Think of it like your marketing campaign blueprint. It defines your overall strategy: who you're targeting, the message you want to convey, and the different steps involved, like sending emails, SMS messages or even making calls.  It's the master plan for reaching out to potential customers efficiently and automatically.</p>"},{"location":"uui/01_goai_campaign/#key-concepts","title":"Key Concepts","text":"<ul> <li>Target Audience: This is the group of people you want to reach. In GoAI, you select a pre-defined audience from your Customer Data Platform (CDP). Think of this like choosing a mailing list.</li> <li>Message:  This is the information you want to share with your audience. It can be anything from a promotional offer to an invitation to a webinar. In GoAI, you can define various messages tailored to different communication channels (e.g., email, SMS, calls).</li> <li>Steps: These are the actions taken during your campaign. A step could be sending an email, making a phone call, or sending a LinkedIn message.  Each step has its own specific message and settings.</li> </ul>"},{"location":"uui/01_goai_campaign/#building-a-simple-goai-campaign","title":"Building a Simple GoAI Campaign","text":"<p>Let's say you want to run a simple email campaign to invite potential customers to a webinar.  Here's how you'd use a GoAI Campaign to do this:</p> <ol> <li> <p>Create a Campaign: First, you'd create a new GoAI Campaign and give it a title like \"Webinar Invitation Campaign.\"</p> </li> <li> <p>Define Your Target Audience: You select your target audience from your CDP. Let's say you choose an audience called \"Potential Leads.\"</p> </li> <li> <p>Add a Step (Email):  You add an email step to your campaign. Within this step, you craft the email message inviting people to the webinar.  </p> </li> </ol> <p><pre><code># Simplified example: Creating a campaign step\ncampaign_step = Goai::CampaignStep.new(type: \"EMAIL\", prompt: \"Join our webinar!\")\n</code></pre>    This creates a new campaign step of type \"EMAIL\" with the prompt \"Join our webinar!\". The prompt serves as the basis for generating the email content. You'll learn more about GoAI Campaign Steps in the next chapter.</p> <ol> <li>Generate and Send Messages: GoAI will then use your campaign settings and selected audience data to generate personalized email messages for each person in your target audience. These messages are then sent automatically.</li> </ol>"},{"location":"uui/01_goai_campaign/#under-the-hood","title":"Under the Hood","text":"<p>When you launch a GoAI Campaign, here's a simplified look at what happens behind the scenes:</p> <pre><code>sequenceDiagram\n    participant User\n    participant GoAI Campaign\n    participant CDP\n    participant Go Engage\n    User-&gt;&gt;GoAI Campaign: Start Campaign\n    GoAI Campaign-&gt;&gt;CDP: Fetch Audience Data\n    CDP--&gt;&gt;GoAI Campaign: Audience Data\n    loop For each contact\n        GoAI Campaign-&gt;&gt;GoAI Campaign: Generate Personalized Message\n        GoAI Campaign-&gt;&gt;Go Engage: Send Message\n        Go Engage--&gt;&gt;GoAI Campaign: Message Sent Confirmation\n    end\n</code></pre> <ol> <li>Fetch Audience Data: The GoAI Campaign retrieves the contact information for each person in your chosen target audience from the CDP.</li> <li>Generate Personalized Message:  For each contact, the campaign uses its message templates and AI to create a personalized message.</li> <li>Send Message:  The personalized message is then sent through the appropriate channel (in this example, email) using Go Engage.</li> </ol>"},{"location":"uui/01_goai_campaign/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Goai::Campaign</code> model (app/models/goai/campaign.rb) is the core of the GoAI Campaign. It handles everything from defining the campaign's settings (like the target audience and campaign type) to managing the campaign steps and generating messages.</p> <pre><code># app/models/goai/campaign.rb (simplified)\nclass Goai::Campaign &lt; ApplicationRecord\n  has_many :campaign_steps # Connects the campaign to its steps\n  # ... other code ...\nend\n</code></pre> <p>The <code>has_many :campaign_steps</code> line establishes the relationship between a campaign and its individual steps.  You'll learn more about steps in the next chapter.</p>"},{"location":"uui/01_goai_campaign/#conclusion","title":"Conclusion","text":"<p>In this chapter, you learned about the GoAI Campaign \u2013 your blueprint for automated, personalized marketing campaigns. We covered the key concepts and walked through a simple example of creating an email campaign.  In the next chapter, we'll dive deeper into the GoAI Campaign Steps that make up your campaign's actions.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/01_messenger/","title":"Chapter 1: Messenger","text":"<p>Let's imagine you want to add a live chat widget to your website so your customers can easily contact you.  The <code>Messenger</code> component in <code>uui</code> is the tool that makes this happen! It's the main UI component that displays the chat window on your webpage. It takes care of everything the user sees and interacts with, like showing messages and sending them to your server.  Think of the <code>Messenger</code> as the storefront of your chat application.</p>"},{"location":"uui/01_messenger/#embedding-the-messenger","title":"Embedding the Messenger","text":"<p>To get started, you need to add the <code>Messenger</code> to your webpage. It's like building the storefront of your chat shop.  We do this by adding a bit of Javascript code.</p> <p>Here's a simplified version of how it works:</p> <pre><code>// app/javascript/embed.js\nimport ChaskiqMessengerEncrypted from '@chaskiq/messenger/src/client_messenger/messengerEncrypted';\n\nwindow.ChaskiqMessengerEncrypted = ChaskiqMessengerEncrypted;\n</code></pre> <p>This code imports the <code>ChaskiqMessengerEncrypted</code> component and makes it available to your webpage's Javascript. This is like bringing in the blueprints for your chat storefront.</p> <p>Next, you\u2019ll initialize the Messenger with some options:</p> <p><pre><code>// app/javascript/new_embed.js (simplified)\nwindow.Chaskiq = { /* ... */ }; // Contains helper functions\n\nwindow.Chaskiq.load = function (options) {\n  this.options = options; // Store the options\n  window.Chaskiq.initPopupWidget(options); // Initialize the widget\n  // ... other initialization logic\n}\n</code></pre> The <code>load</code> function in <code>new_embed.js</code> is responsible for taking your specific settings (like your app ID and domain) and using them to configure the Messenger. <code>initPopupWidget</code> then uses these options to build and display the widget on the page.</p>"},{"location":"uui/01_messenger/#under-the-hood","title":"Under the Hood","text":"<p>When a user visits your webpage, the Javascript code creates a new <code>Messenger</code> instance. This <code>Messenger</code>  handles user interactions, message display, and sending messages back to the server.  Let's see a simplified sequence diagram of how it works when a user sends a message:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n\n    User-&gt;&gt;Browser: Types a message and presses Enter\n    Browser-&gt;&gt;Messenger: Sends the message\n    Messenger-&gt;&gt;Server: Sends the message to the backend\n    Server--&gt;&gt;Messenger: Confirms message received\n    Messenger-&gt;&gt;Browser: Updates the chat window with the message\n    Browser-&gt;&gt;User: Displays the message in the chat window\n</code></pre> <p>The <code>Messenger</code> component interacts with the backend using a combination of techniques.  It uses events to communicate with the parent frame and ultimately make requests to the server.</p> <pre><code>// app/javascript/new_embed.js (simplified)\npushEvent: async function (eventType, data) {\n  // ... Code to send the event to the iframe\n}\n</code></pre> <p>This <code>pushEvent</code> function sends the event and data to the iframe, which is like sending a message to the back of your chat storefront. This is explained in detail in Stimulus Controllers.</p>"},{"location":"uui/01_messenger/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about the <code>Messenger</code> component, the heart of <code>uui</code>'s chat widget.  We saw how to embed it on your webpage and got a peek under the hood to understand how it works.  In the next chapter, we'll explore Conversations, which represent individual chat threads within the Messenger.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/02_conversations/","title":"Chapter 2: Conversations","text":"<p>Continuing from our exploration of the Messenger, which acts as the storefront of our chat application, let's delve into the concept of <code>Conversations</code>.</p> <p>Imagine a busy store with multiple customers interacting with staff. Each individual interaction between a customer and a staff member is like a <code>Conversation</code> in <code>uui</code>.  Conversations help organize and manage these individual chat threads within the Messenger.  They keep track of the message history, which agent is assigned, and the current status of the conversation (e.g., open, closed).</p>"},{"location":"uui/02_conversations/#understanding-conversations","title":"Understanding Conversations","text":"<p>Let's break down the core aspects of a <code>Conversation</code>:</p> <ul> <li>Message History: Just like remembering what was discussed with a customer, the <code>Conversation</code> stores all messages exchanged between the user and the agent.</li> <li>Agent Assignment: This is like assigning a specific staff member to assist a particular customer. In <code>uui</code>, an agent can be assigned to a <code>Conversation</code> to handle it.</li> <li>Conversation Status:  This indicates the current state of the interaction \u2013 is the customer still actively chatting (open) or has the issue been resolved (closed)?  Just like knowing if a customer is still browsing or has left the store.</li> </ul>"},{"location":"uui/02_conversations/#using-conversations","title":"Using Conversations","text":"<p>When a user starts a new chat in the <code>Messenger</code>, a new <code>Conversation</code> is created behind the scenes.  Let\u2019s imagine a user sends the message \"Hello, I need help!\".  </p> <p>This triggers the creation of a new <code>Conversation</code> and adds the message to its history.  This is similar to a new customer walking into the store and starting a conversation.</p> <pre><code>// Simplified example of creating a conversation (backend)\nconst conversation = new Conversation();\nconversation.messages.push(\"Hello, I need help!\");\nconversation.status = \"open\";\nconversation.save();\n</code></pre> <p>This simplified backend code creates a new <code>Conversation</code> object, adds the user's message, marks the status as \"open\", and saves it.  The actual implementation uses more complex logic to handle agent assignment and other details.</p>"},{"location":"uui/02_conversations/#under-the-hood","title":"Under the Hood","text":"<p>Let\u2019s see what happens when a user sends a message in an existing conversation:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n    participant Conversation\n\n    User-&gt;&gt;Browser: Types a message\n    Browser-&gt;&gt;Messenger: Sends the message\n    Messenger-&gt;&gt;Server: Sends the message to the backend\n    Server-&gt;&gt;Conversation: Adds the message to the conversation history\n    Server--&gt;&gt;Messenger: Confirms message received\n    Messenger-&gt;&gt;Browser: Updates the chat window\n    Browser-&gt;&gt;User: Displays the message\n</code></pre> <p>The <code>Conversation</code> is updated on the server-side whenever a new message is sent or the conversation status changes. The <code>Messenger</code> then displays the updated conversation to the user.</p> <p>The following code snippet (heavily simplified) demonstrates how the <code>conversations</code> component retrieves and displays existing conversations within the Messenger:</p> <pre><code>// app/javascript/packages/messenger/src/client_messenger/conversations/conversations.tsx\n// ... other code ...\n\n{conversations.map((o) =&gt; {\n  // ... code to display each conversation ...\n})}\n\n// ... other code ...\n</code></pre> <p>This code snippet shows how the list of <code>conversations</code> is iterated over and displayed in the Messenger's UI.</p>"},{"location":"uui/02_conversations/#conclusion","title":"Conclusion","text":"<p>This chapter introduced the concept of <code>Conversations</code> and their importance in managing individual chat interactions within the Messenger.  We explored the key components of a <code>Conversation</code> and saw how they work together to manage the flow of messages and agent assignments. In the next chapter, we'll learn about AppPackages, which allow you to add interactive elements to your conversations.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/02_goai_campaign_step/","title":"Chapter 2: GoAI Campaign Step","text":"<p>Continuing from our discussion on GoAI Campaigns, let's look at the individual building blocks that make them up: GoAI Campaign Steps.</p> <p>Imagine you\u2019re planning a trip.  Your overall trip is the \"campaign,\" but each part of the journey\u2014like flying to your destination, checking into your hotel, and visiting a museum\u2014are individual \"steps.\"  Similarly, a GoAI Campaign Step is a single action within your automated marketing campaign.</p>"},{"location":"uui/02_goai_campaign_step/#key-concepts","title":"Key Concepts","text":"<p>A GoAI Campaign Step represents a specific interaction with a customer.  Each step can be a different type of communication:</p> <ul> <li>Email: Sending a personalized email message.</li> <li>SMS: Sending a text message.</li> <li>LinkedIn Message: Sending a message through LinkedIn.</li> <li>Call: Making a phone call (either by a human or using AI).</li> </ul> <p>Each step within your GoAI Campaign is executed in a defined order, just like your trip itinerary.</p>"},{"location":"uui/02_goai_campaign_step/#building-a-simple-email-campaign-step","title":"Building a Simple Email Campaign Step","text":"<p>In the last chapter, we touched upon adding an email step to our \"Webinar Invitation Campaign.\" Let's expand on that:</p> <pre><code># Simplified example: Creating a campaign step\ncampaign_step = Goai::CampaignStep.new(type: \"EMAIL\", prompt: \"Join our webinar!\")\n</code></pre> <p>This code creates a new campaign step.  <code>type: \"EMAIL\"</code> specifies that this step will send an email. <code>prompt: \"Join our webinar!\"</code> provides a starting point for GoAI to generate the actual email content. This prompt can be further refined and personalized later using GoAI Campaign Messages.</p>"},{"location":"uui/02_goai_campaign_step/#under-the-hood","title":"Under the Hood","text":"<p>When a GoAI Campaign runs and reaches a specific step, here's a simplified look at what happens:</p> <pre><code>sequenceDiagram\n    participant GoAI Campaign\n    participant Campaign Step\n    participant Message Generator\n    participant Go Engage\n    GoAI Campaign-&gt;&gt;Campaign Step: Execute Step\n    Campaign Step-&gt;&gt;Message Generator: Generate Message Content\n    Message Generator--&gt;&gt;Campaign Step: Message Content\n    Campaign Step-&gt;&gt;Go Engage: Send Message\n    Go Engage--&gt;&gt;Campaign Step: Message Sent Confirmation\n</code></pre> <ol> <li>Execute Step: The GoAI Campaign triggers the execution of the next Campaign Step.</li> <li>Generate Message Content:  The Campaign Step uses its prompt and AI to generate the content of the message.</li> <li>Send Message: The generated message is sent using Go Engage.</li> </ol>"},{"location":"uui/02_goai_campaign_step/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Goai::CampaignStep</code> model (app/models/goai/campaign_step.rb) defines the structure and behavior of individual steps.</p> <pre><code># app/models/goai/campaign_step.rb (simplified)\nclass Goai::CampaignStep &lt; ApplicationRecord\n  belongs_to :campaign, class_name: \"Goai::Campaign\"\n  # ... other code ...\nend\n</code></pre> <p>The <code>belongs_to :campaign</code> line connects each step to its parent campaign. The <code>type</code> attribute stores the type of step (EMAIL, SMS, etc.), and the <code>prompt</code> attribute stores the instruction for generating the message content.</p>"},{"location":"uui/02_goai_campaign_step/#conclusion","title":"Conclusion","text":"<p>In this chapter, you\u2019ve learned how GoAI Campaign Steps work as individual actions within a campaign.  We saw how different types of steps can be created and how they are executed. In the next chapter, we\u2019ll explore how to further customize these messages using GoAI Campaign Messages.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/03_apppackages/","title":"Chapter 3: AppPackages","text":"<p>In the previous chapter on Conversations, we learned how <code>uui</code> manages individual chat threads within the Messenger.  Now, let's explore how to make those conversations more interactive and useful with <code>AppPackages</code>.</p> <p>Imagine you want to collect some basic information from your users, like their email address, before starting a conversation.  Or maybe you want to offer them helpful resources, like links to your FAQ page. <code>AppPackages</code> allow you to do these things and much more! They're like mini-apps within your chat widget, providing specific functions and enhancing the user experience.</p>"},{"location":"uui/03_apppackages/#what-are-apppackages","title":"What are AppPackages?","text":"<p><code>AppPackages</code> are reusable components that add functionality to your Messenger. Think of them as apps on your phone.  They can:</p> <ul> <li>Display interactive UI elements (buttons, forms, lists)</li> <li>Collect user information</li> <li>Integrate with third-party services</li> <li>Show dynamic content</li> </ul>"},{"location":"uui/03_apppackages/#building-our-first-apppackage","title":"Building our first AppPackage","text":"<p>Let's build a simple AppPackage that greets the user with a welcome message.  This is like having a friendly store greeter.</p> <p>First, we define the structure and content of our AppPackage using a JSON-like format. This structure is called <code>definitions</code>:</p> <pre><code>// Simplified AppPackage definition\nconst myPackage = {\n  name: \"WelcomeMessage\",\n  definitions: [\n    { type: \"text\", text: \"Hello there!\" }\n  ]\n};\n</code></pre> <p>This definition creates an AppPackage named \"WelcomeMessage\" which simply displays the text \"Hello there!\".  The <code>type: \"text\"</code> indicates we want to display a simple text message.</p>"},{"location":"uui/03_apppackages/#integrating-the-apppackage-into-the-messenger","title":"Integrating the AppPackage into the Messenger","text":"<p>Next, we need to add our AppPackage to the Messenger's home screen.  This is like placing our greeter at the store entrance.  We do this by configuring our app settings (simplified example):</p> <pre><code>// Simplified app configuration (backend)\nconst app = { \n  // ... other settings ...\n  visitor_home_apps: [ myPackage ]\n};\n</code></pre> <p>This adds our <code>myPackage</code> to the <code>visitor_home_apps</code> array, which tells the <code>Messenger</code> to display it on the home screen.</p>"},{"location":"uui/03_apppackages/#under-the-hood","title":"Under the Hood","text":"<p>When a user opens the Messenger, it fetches the configured <code>AppPackages</code> from the server and renders them based on their definitions.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n    participant AppPackage\n\n    User-&gt;&gt;Browser: Opens the Messenger\n    Browser-&gt;&gt;Messenger: Requests home screen content\n    Messenger-&gt;&gt;Server: Requests AppPackages\n    Server--&gt;&gt;Messenger: Sends AppPackage definitions\n    Messenger-&gt;&gt;AppPackage: Renders the AppPackage UI\n    Browser-&gt;&gt;User: Displays the welcome message\n</code></pre> <p>The <code>Messenger</code> uses a component to handle the rendering of <code>AppPackages</code>. Here's a simplified example:</p> <pre><code>// app/javascript/packages/components/src/components/packageBlocks/baseInserter.tsx (simplified)\n// ... other code ...\n{p &amp;&amp; (\n  &lt;DefinitionRenderer \n    schema={p.definitions} \n    // ... other props ...\n  /&gt;\n)}\n// ... other code ...\n</code></pre> <p>This code snippet shows how the <code>DefinitionRenderer</code> component uses the <code>definitions</code> from the <code>AppPackage</code> (represented by <code>p</code>) to render the UI.</p>"},{"location":"uui/03_apppackages/#more-complex-apppackages","title":"More Complex AppPackages","text":"<p>We can create more complex AppPackages by adding more elements to the <code>definitions</code> array.  For instance, we can add a button:</p> <pre><code>const myPackage = {\n  // ...\n  definitions: [\n    // ...\n    { \n      type: \"button\", \n      label: \"Click me!\", \n      action: { type: \"submit\" } // Action to perform on click\n    }\n  ]\n};\n</code></pre> <p>This adds a button labeled \"Click me!\" to our AppPackage. The <code>action</code> property defines what happens when the button is clicked. In this case, it triggers a \"submit\" action, which can be handled to perform specific tasks.</p>"},{"location":"uui/03_apppackages/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about <code>AppPackages</code> and how they extend the functionality of the Messenger.  We built a simple welcome message AppPackage and explored how to integrate it into the Messenger's home screen. We also saw how to create more complex AppPackages with interactive elements like buttons.  In the next chapter, we'll explore Bot Tasks, which automate actions and responses within your conversations.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/03_goai_campaign_message/","title":"Chapter 3: GoAI Campaign Message","text":"<p>Continuing from our discussion on GoAI Campaign Steps, let's explore how to personalize the content of each step using GoAI Campaign Messages.</p> <p>Imagine you\u2019re sending out invitations to a webinar. You wouldn't send the exact same email to everyone. You might want to address people by name, mention their company, or tailor the message based on their past interactions with your business. That's what GoAI Campaign Messages allow you to do.  They provide the personalized content delivered within each GoAI Campaign Step.</p>"},{"location":"uui/03_goai_campaign_message/#key-concepts","title":"Key Concepts","text":"<ul> <li>Personalized Content:  A GoAI Campaign Message holds the specific content to be delivered, like the text of an email, an SMS message, or the script for a phone call.  This content can be personalized using data from your GoAI Campaign's target audience.</li> <li>Connection to Campaign Step: Each GoAI Campaign Step can have one or more associated Campaign Messages.  This allows you to have variations in your messaging within a single step. For example, you could have different email templates for different segments of your audience within the same email sending step.</li> </ul>"},{"location":"uui/03_goai_campaign_message/#building-personalized-messages","title":"Building Personalized Messages","text":"<p>Let's enhance our \"Webinar Invitation Campaign\" email step with personalized messages:</p> <pre><code># Simplified example: Creating a campaign message\n\ncontact = { \"FIRST_NAME\" =&gt; \"Alice\", \"COMPANY_NAME\" =&gt; \"Acme Corp\" }\nmessage_content = \"Hi #{contact[\"FIRST_NAME\"]}, join our webinar tailored for professionals at #{contact[\"COMPANY_NAME\"]}!\"\n\ncampaign_message = Goai::CampaignMessage.new(messages: [{ \"type\" =&gt; \"EMAIL\", \"body\" =&gt; message_content}])\n</code></pre> <p>This code creates a new Campaign Message.  The <code>messages</code> attribute holds an array of message details. In this simple case, we have one message of type \"EMAIL\" with a personalized body.</p>"},{"location":"uui/03_goai_campaign_message/#under-the-hood","title":"Under the Hood","text":"<p>When a GoAI Campaign runs and reaches a step requiring personalized content, here's what happens:</p> <pre><code>sequenceDiagram\n    participant GoAI Campaign\n    participant Campaign Step\n    participant Campaign Message\n    participant Go Engage\n    GoAI Campaign-&gt;&gt;Campaign Step: Execute Step\n    Campaign Step-&gt;&gt;Campaign Message: Fetch Personalized Content\n    Campaign Message--&gt;&gt;Campaign Step: Content for Alice from Acme Corp\n    Campaign Step-&gt;&gt;Go Engage: Send Message with Personalized Content\n    Go Engage--&gt;&gt;Campaign Step: Message Sent Confirmation\n</code></pre> <ol> <li>Execute Step: The campaign triggers the execution of a Campaign Step.</li> <li>Fetch Personalized Content: The step retrieves the personalized content from the relevant Campaign Message.  This content is tailored based on the recipient's information.</li> <li>Send Message: Go Engage sends the personalized message.</li> </ol>"},{"location":"uui/03_goai_campaign_message/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Goai::CampaignMessage</code> model (app/models/goai/campaign_message.rb) stores and manages these personalized messages.</p> <pre><code># app/models/goai/campaign_message.rb (simplified)\nclass Goai::CampaignMessage &lt; ApplicationRecord\n  belongs_to :campaign, class_name: \"Goai::Campaign\"\n  serialize :messages, coder: JSON # Stores message details\nend\n</code></pre> <p>The <code>serialize :messages</code> line allows storing complex message data (like subject, body, etc.) as JSON.  The <code>belongs_to :campaign</code> line connects the message to its parent campaign.</p>"},{"location":"uui/03_goai_campaign_message/#conclusion","title":"Conclusion","text":"<p>In this chapter, we explored how GoAI Campaign Messages enable personalized content within your automated campaigns.  You learned how to create these messages and how they work with GoAI Campaign Steps.  Next, we'll look at how to orchestrate more complex sequences of actions using Engage Sequences.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/04_bot_tasks/","title":"Chapter 4: Bot Tasks","text":"<p>In the previous chapter on AppPackages, we learned how to add interactive elements to our Messenger. Now, let's explore how to automate conversations with <code>Bot Tasks</code>.  Imagine you want to greet users, ask qualifying questions, and provide helpful resources automatically.  Bot Tasks let you do exactly that! They're like automated scripts that guide the conversation based on user input.</p>"},{"location":"uui/04_bot_tasks/#automating-a-welcome-message","title":"Automating a Welcome Message","text":"<p>Let's say we want to create a bot that welcomes users and asks for their email address.  This is like having a receptionist who greets everyone and collects contact information.</p> <p>A Bot Task is composed of different paths. Let\u2019s start by creating a simple path:</p> <pre><code>// Simplified Bot Task definition (backend)\nconst myBotTask = {\n  title: \"Welcome Bot\",\n  paths: [\n    {\n      title: \"Welcome Path\",\n      steps: [\n        { type: \"text\", text: \"Hello! Welcome to our store.\" }\n      ]\n    }\n  ]\n}\n</code></pre> <p>This defines a Bot Task named \"Welcome Bot\" with one path named \"Welcome Path\".  The path has one step that displays a simple welcome message. <code>type: \"text\"</code> is similar to how we defined text in AppPackages.</p>"},{"location":"uui/04_bot_tasks/#adding-user-input","title":"Adding User Input","text":"<p>Now, let's ask for the user's email.  We'll add another step to our path:</p> <pre><code>// Simplified Bot Task definition (backend)\n// ... previous code ...\n      steps: [\n        // ... previous step ...\n        { type: \"input\", label: \"Your Email\", name: \"email\" }\n      ]\n// ... remaining code ...\n</code></pre> <p>We've added a step with <code>type: \"input\"</code>. This will display a text field where the user can enter their email address. The <code>label</code> sets the text displayed next to the field, and <code>name</code> is used to identify the collected value.</p>"},{"location":"uui/04_bot_tasks/#triggering-the-bot-task","title":"Triggering the Bot Task","text":"<p>We can trigger our Bot Task when a new Conversation starts.  This is like instructing our receptionist to greet every new customer.  We do this in our app settings (simplified example):</p> <pre><code>// Simplified app configuration (backend)\nconst app = {\n  // ... other settings ...\n  new_conversations_bot_task: myBotTask\n};\n</code></pre> <p>This configuration tells the Messenger to run the <code>myBotTask</code> whenever a new conversation begins.</p>"},{"location":"uui/04_bot_tasks/#under-the-hood","title":"Under the Hood","text":"<p>When a user starts a chat, the <code>Messenger</code> initiates the designated Bot Task. The Bot Task follows the defined path, executing each step sequentially.</p> <pre><code>sequenceDiagram\n  participant User\n  participant Browser\n  participant Messenger\n  participant Server\n  participant Bot Task\n\n  User-&gt;&gt;Browser: Starts a chat\n  Browser-&gt;&gt;Messenger: New conversation event\n  Messenger-&gt;&gt;Server: Triggers Bot Task\n  Server-&gt;&gt;Bot Task: Executes \"Welcome Path\"\n  Bot Task--&gt;&gt;Messenger: Sends welcome message\n  Messenger-&gt;&gt;Browser: Displays welcome message\n  Bot Task--&gt;&gt;Messenger: Sends email input field\n  Messenger-&gt;&gt;Browser: Displays email input field\n</code></pre> <p>The <code>Messenger</code> component interacts with the server to execute the <code>Bot Task</code>. Relevant code snippets (heavily simplified):</p> <pre><code>// app/javascript/controllers/bots_controller.js (simplified)\n// ... other code ...\ninitialize() {\n  // ... initialization logic\n}\n// ... other code ...\n</code></pre> <p>This <code>bots_controller.js</code> file handles the logic for displaying and interacting with Bot Tasks within the Messenger.</p>"},{"location":"uui/04_bot_tasks/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about Bot Tasks and how they automate conversations.  We built a simple Bot Task that welcomes users and collects their email.  We also explored how to trigger the Bot Task at the start of a new Conversation. In the next chapter, we will learn about Tours, which guide users through specific features of your application.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/04_engage_sequence/","title":"Chapter 4: Engage Sequence","text":"<p>Building on our knowledge of GoAI Campaigns, GoAI Campaign Steps, and GoAI Campaign Messages, let's explore the powerful concept of Engage Sequences.</p> <p>Imagine you want to nurture leads over time with a series of automated messages.  You might send a welcome email, followed by a product demo video link a few days later, and finally, a special offer a week after that.  Doing this manually for each lead would be tedious.  Engage Sequences automate this entire process, much like an automated email drip campaign.</p>"},{"location":"uui/04_engage_sequence/#key-concepts","title":"Key Concepts","text":"<p>An Engage Sequence is like a sophisticated GoAI Campaign specifically designed for multi-step, automated communication.  Here\u2019s a breakdown:</p> <ul> <li>Enrollment: Contacts are enrolled in a sequence, similar to adding them to an email list.</li> <li>Steps:  Just like GoAI Campaign Steps, an Engage Sequence consists of multiple steps, each representing a specific communication action (e.g., sending an email, SMS, making a call).</li> <li>Automated Sending:  The system automatically sends messages at pre-defined intervals or based on specific triggers, like a contact opening an email or clicking a link.</li> </ul>"},{"location":"uui/04_engage_sequence/#building-a-simple-engage-sequence","title":"Building a Simple Engage Sequence","text":"<p>Let's create a simple email sequence to welcome new leads:</p> <ol> <li> <p>Create a Sequence: First, you create a new Engage Sequence and give it a descriptive name like \"New Lead Welcome Sequence.\"</p> </li> <li> <p>Add Steps: You add steps to the sequence, defining the type of communication and the content for each step. For example:</p> <p><pre><code># Simplified example - Adding an email step\nsequence_step1 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 0, wait_mode: \"minute\") # Send immediately\nsequence_step2 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 3, wait_mode: \"day\") # Send after 3 days\n</code></pre> This code creates two email steps. The first step sends an email immediately (<code>wait_time: 0</code>). The second step sends an email after a 3-day delay (<code>wait_time: 3</code>, <code>wait_mode: \"day\"</code>).  You'll define the actual email content using Engage Sequence Step Content.</p> </li> <li> <p>Enroll Contacts:  You enroll contacts into your sequence. This is handled by Engage Sequence Membership.</p> </li> </ol>"},{"location":"uui/04_engage_sequence/#under-the-hood","title":"Under the Hood","text":"<p>When a contact is enrolled in an active Engage Sequence:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Engage Sequence\n    participant Sequence Step\n    participant Go Engage\n    User-&gt;&gt;Engage Sequence: Enroll Contact\n    Activate Engage Sequence\n    loop For each step\n        Engage Sequence-&gt;&gt;Sequence Step: Execute Step\n        Sequence Step-&gt;&gt;Go Engage: Send Message\n        Go Engage--&gt;&gt;Sequence Step: Message Sent Confirmation\n    end\n</code></pre> <ol> <li>Enroll Contact: A user is enrolled in the sequence.</li> <li>Activate Engage Sequence: The sequence becomes active for the user.</li> <li>Execute Step: The sequence executes each step in order, sending the corresponding message through Go Engage.</li> </ol>"},{"location":"uui/04_engage_sequence/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::Sequence</code> model (app/models/engage/sequence.rb) is at the heart of this functionality:</p> <pre><code># app/models/engage/sequence.rb (simplified)\nclass Engage::Sequence &lt; ApplicationRecord\n  has_many :sequence_steps\n  # ... other code ...\nend\n</code></pre> <p>The <code>has_many :sequence_steps</code> establishes the relationship between a sequence and its steps.</p>"},{"location":"uui/04_engage_sequence/#conclusion","title":"Conclusion","text":"<p>This chapter introduced Engage Sequences, powerful tools for automated, multi-step communication. We covered the basic concepts and a simple example of creating an email sequence.  In the next chapter, we'll dive into the details of individual steps with Engage Sequence Step.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/05_engage_sequence_step/","title":"Chapter 5: Engage Sequence Step","text":"<p>Continuing from our discussion on Engage Sequences, let's dive into the individual components that make them tick: Engage Sequence Steps.</p> <p>Imagine you're baking a cake. The entire recipe is the \"Engage Sequence,\" but each instruction, like \"mix the dry ingredients\" or \"bake for 30 minutes,\" is an \"Engage Sequence Step.\"  Each step represents a specific action within the sequence.</p>"},{"location":"uui/05_engage_sequence_step/#key-concepts","title":"Key Concepts","text":"<ul> <li>Type:  Specifies what kind of action the step performs, such as sending an email (<code>Engage::EmailStep</code>), an SMS (<code>Engage::SmsStep</code>), or making a call (<code>Engage::VoiceAiStep</code>). You'll learn more about step types in the next chapter, Engage Sequence Step Content.</li> <li>Wait Time:  Defines how long to wait before executing this step after the previous one. This creates the delay between messages in your sequence.</li> <li>Wait Mode: Specifies the unit of time for the <code>wait_time</code>: minutes, hours, or days.</li> </ul>"},{"location":"uui/05_engage_sequence_step/#building-a-simple-email-sequence-step","title":"Building a Simple Email Sequence Step","text":"<p>Let's add two email steps to our \"New Lead Welcome Sequence\":</p> <pre><code># First step: Send a welcome email immediately\nsequence_step1 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 0, wait_mode: \"minute\")\n\n# Second step: Send a follow-up email 3 days later\nsequence_step2 = Engage::SequenceStep.new(type: \"Engage::EmailStep\", wait_time: 3, wait_mode: \"day\")\n</code></pre> <p>The first step sends an email immediately after a contact is enrolled in the sequence (<code>wait_time: 0</code>).  The second step sends another email 3 days after the first one (<code>wait_time: 3</code>, <code>wait_mode: \"day\"</code>).  The actual content of these emails is handled by Engage Sequence Step Content, which we'll cover in the next chapter.</p>"},{"location":"uui/05_engage_sequence_step/#under-the-hood","title":"Under the Hood","text":"<p>When an Engage Sequence is running, here's how it processes each step:</p> <pre><code>sequenceDiagram\n    participant Sequence\n    participant Step 1\n    participant Go Engage\n    participant Step 2\n    Sequence-&gt;&gt;Step 1: Execute\n    Step 1-&gt;&gt;Go Engage: Send Email 1\n    Go Engage--&gt;&gt;Step 1: Confirmation\n    Note right of Step 1: Wait 3 days\n    Sequence-&gt;&gt;Step 2: Execute\n    Step 2-&gt;&gt;Go Engage: Send Email 2\n    Go Engage--&gt;&gt;Step 2: Confirmation\n</code></pre> <ol> <li>Execute: The sequence executes the current step.</li> <li>Send Message:  The step triggers Go Engage to send the message (in this case, an email).</li> <li>Confirmation: Go Engage confirms that the message was sent.</li> <li>Wait: The sequence waits the specified <code>wait_time</code> before proceeding to the next step.</li> </ol>"},{"location":"uui/05_engage_sequence_step/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceStep</code> model (app/models/engage/sequence_step.rb) defines the structure and behavior of individual steps:</p> <pre><code># app/models/engage/sequence_step.rb (simplified)\nclass Engage::SequenceStep &lt; ApplicationRecord\n  belongs_to :sequence, class_name: \"Engage::Sequence\"\n  # ... other code related to content, events, etc. ...\nend\n</code></pre> <p>The <code>belongs_to :sequence</code> line links each step to its parent sequence. The <code>type</code>, <code>wait_time</code>, and <code>wait_mode</code> attributes store the step's configuration.</p>"},{"location":"uui/05_engage_sequence_step/#conclusion","title":"Conclusion","text":"<p>This chapter explained how Engage Sequence Steps work as the individual actions within an Engage Sequence. We explored the key concepts of step type, wait time, and wait mode. In the next chapter, we'll delve into Engage Sequence Step Content to learn how to define the actual messages sent in each step.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/05_tours/","title":"Chapter 5: Tours","text":"<p>Following our discussion on automating actions with Bot Tasks, let's explore how to guide users through your application with <code>Tours</code>. Imagine you've just redesigned your website and want to highlight the new features to your users.  Tours provide a step-by-step walkthrough, highlighting key elements and explaining their functionality. They act like a guide, pointing out important areas and providing helpful information.</p>"},{"location":"uui/05_tours/#guiding-users-through-new-features","title":"Guiding Users Through New Features","text":"<p>Let's say you've added a new \"Help\" button to your Messenger and want to ensure your users know about it. We can create a Tour to highlight this button.</p> <p>A Tour consists of several steps. Each step highlights a specific element on the page and provides a description.  Let\u2019s create our first step:</p> <pre><code>// Simplified Tour step definition (backend)\nconst tourStep = {\n  target: \"#help-button\", // CSS selector for the Help button\n  serialized_content: JSON.stringify({ blocks: [{ type: \"text\", text: \"Click here for help!\" }]})\n};\n</code></pre> <p>This defines a single step in our Tour. <code>target</code> specifies the HTML element to highlight (in this case, the Help button using its ID).  <code>serialized_content</code> contains the message to display next to the highlighted element.  Notice how it uses a structure similar to AppPackages for the content definition.</p>"},{"location":"uui/05_tours/#creating-a-tour","title":"Creating a Tour","text":"<p>Now let\u2019s create a Tour using this step.  We\u2019ll keep it simple with just one step for now:</p> <pre><code>// Simplified Tour definition (backend)\nconst myTour = {\n  url: \"/help\", // URL where the Tour should be active\n  steps: [tourStep]\n};\n</code></pre> <p>This creates a Tour that will be active on the \"/help\" URL.  The <code>steps</code> array contains all the steps of the Tour, in this case just our single <code>tourStep</code>.</p>"},{"location":"uui/05_tours/#enabling-the-tour","title":"Enabling the Tour","text":"<p>Finally, we need to enable our Tour so it's displayed to the user.  This is like telling our guide to start the tour.  We\u2019ll do this by setting the Tour state to \u201cenabled\u201d (simplified backend example):</p> <pre><code>// Simplified code to enable a Tour (backend)\nmyTour.state = \"enabled\";\nmyTour.save();\n</code></pre> <p>This code enables <code>myTour</code> and saves it, making it active for users visiting the specified URL.</p>"},{"location":"uui/05_tours/#under-the-hood","title":"Under the Hood","text":"<p>When a user visits the specified URL, the Messenger checks for any enabled Tours. If it finds one, it displays the Tour steps to the user.</p> <pre><code>sequenceDiagram\n  participant User\n  participant Browser\n  participant Messenger\n  participant Server\n  participant Tour\n\n  User-&gt;&gt;Browser: Visits /help\n  Browser-&gt;&gt;Messenger: Requests page content\n  Messenger-&gt;&gt;Server: Checks for enabled Tours\n  Server--&gt;&gt;Messenger: Sends Tour data\n  Messenger-&gt;&gt;Tour: Starts the Tour\n  Browser-&gt;&gt;User: Displays Tour step highlighting the Help button\n</code></pre> <p>The <code>UserTour</code> component handles the display and logic of the Tour in the frontend.  Here's a simplified snippet demonstrating how the Tour steps are rendered:</p> <pre><code>// app/javascript/packages/messenger/src/client_messenger/UserTour.tsx (simplified)\n// ... other code ...\n&lt;Tour\n  steps={this.prepareJoyRidyContent()} // Prepare steps for display\n  isOpen={this.state.run} // Control Tour visibility\n  // ... other props ...\n/&gt;\n// ... other code ...\n</code></pre> <p>This code utilizes the <code>reactour</code> library to render the Tour. <code>prepareJoyRidyContent</code> processes the Tour step definitions for the library.</p>"},{"location":"uui/05_tours/#conclusion","title":"Conclusion","text":"<p>This chapter introduced Tours and how they guide users through your application. We built a simple Tour to highlight a new Help button and saw how to enable it for a specific URL.  In the next chapter, we'll explore Customization options, allowing you to tailor the appearance and behavior of your Messenger to fit your brand.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/06_customization/","title":"Chapter 6: Customization","text":"<p>In the previous chapter on Tours, we learned how to guide users through your application. Now, let's explore how to make your Messenger truly your own with <code>Customization</code> options. Imagine you're decorating your storefront\u2014you want the colors, logo, and overall style to match your brand.  Customization options allow you to tailor the appearance of the Messenger to achieve just that!</p>"},{"location":"uui/06_customization/#branding-your-messenger","title":"Branding Your Messenger","text":"<p>Let's say you want to change the main color of your Messenger to match your brand's primary color, which is a vibrant green.  Customization options make this easy!</p>"},{"location":"uui/06_customization/#customizing-colors","title":"Customizing Colors","text":"<p>You can customize the colors of your Messenger by setting the <code>customization_colors</code> attribute of your app.  Think of it as choosing the paint for your storefront.</p> <pre><code>// Simplified app configuration (backend)\nconst app = {\n  // ... other settings ...\n  customization_colors: {\n    primary: \"#00FF00\" // Vibrant green\n  }\n};\n</code></pre> <p>This sets the primary color of the Messenger to vibrant green. You can also customize the secondary color and other aspects of the appearance.</p>"},{"location":"uui/06_customization/#adding-a-logo","title":"Adding a Logo","text":"<p>You can also add your brand's logo to the Messenger, just like placing a sign above your storefront.  This is done by setting the <code>logo_url</code> attribute:</p> <pre><code>// Simplified app configuration (backend)\nconst app = {\n  // ... other settings ...\n  logo_url: \"https://example.com/my_logo.png\"\n};\n</code></pre> <p>This sets the Messenger's logo to the image located at the specified URL.</p>"},{"location":"uui/06_customization/#under-the-hood","title":"Under the Hood","text":"<p>When the Messenger loads, it retrieves the customization settings from the server. These settings are then applied to the Messenger's styles, changing its appearance.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant Server\n\n    User-&gt;&gt;Browser: Opens the Messenger\n    Browser-&gt;&gt;Messenger: Requests customization settings\n    Messenger-&gt;&gt;Server: Fetches customization data\n    Server--&gt;&gt;Messenger: Sends customization colors and logo URL\n    Messenger-&gt;&gt;Browser: Applies styles to the Messenger\n    Browser-&gt;&gt;User: Displays the customized Messenger\n</code></pre> <p>The <code>style_settings_controller.js</code> file (among others) handles applying the customization settings on the client-side.  Here's a simplified example:</p> <pre><code>// app/javascript/controllers/style_settings_controller.js (simplified)\n// ... other code ...\nconnect() {\n  // ... Logic to apply customization settings ...\n}\n// ... other code ...\n</code></pre> <p>This <code>connect</code> function is called when the controller is initialized, allowing it to apply the custom styles to the Messenger.</p> <p>Tailwind styles and CSS variables are used to apply these customizations dynamically:</p> <pre><code>// engines/astro-plain/tailwind.config.js (simplified)\n// ... other configurations\ntheme: {\n  extend: {\n    colors: {\n      // ... other colors,\n      brand: {\n        500: \"#ec4899\", // Example brand color\n      }\n    }\n  }\n}\n// ...\n</code></pre> <p>This snippet shows how brand colors are defined in the tailwind config, and they can then be used throughout the application.</p>"},{"location":"uui/06_customization/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned how to customize the appearance of the Messenger using <code>Customization</code> options.  We explored how to change colors, add a logo, and saw how these settings are applied under the hood.  This allows you to create a consistent brand experience within your chat widget. In the next chapter, we'll discuss Translations, allowing you to make your Messenger accessible to a wider audience.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/06_engage_sequence_step_content/","title":"Chapter 6: Engage Sequence Step Content","text":"<p>Continuing from our discussion on Engage Sequence Steps, let's explore how to define the actual content of each step: the Engage Sequence Step Content.</p> <p>Imagine you're sending a postcard.  The address and stamp tell the postal service where to send it (Engage Sequence Step), but the message inside is what you actually want to communicate. That's the role of Engage Sequence Step Content. It holds the message template for each step in a sequence. It's like the content of your postcard.</p>"},{"location":"uui/06_engage_sequence_step_content/#key-concepts","title":"Key Concepts","text":"<ul> <li>Message Template:  This is the actual message, like an email body, SMS text, or call script. It can use placeholders (like <code>{{FIRST_NAME}}</code>) for personalization. These placeholders are replaced with real data when the message is sent, similar to mail merge.</li> <li>Connection to Step: Each Engage Sequence Step has one or more associated Step Content items. This lets you have different message variations within a single step.  For example, you could A/B test different email subject lines.</li> </ul>"},{"location":"uui/06_engage_sequence_step_content/#building-content-for-email-steps","title":"Building Content for Email Steps","text":"<p>Let\u2019s add content to the email steps in our \"New Lead Welcome Sequence\":</p> <pre><code># Simplified example - Adding content to the first email step\ncontent1 = Engage::SequenceStepContent.new(\n  stepable_type: \"Engage::EmailStep\", # Specify content type\n  stepable_attributes: { # The actual content\n    subject: \"Welcome to our platform!\",\n    body: \"Hi {{FIRST_NAME}}, thanks for joining!\"\n  }\n)\nsequence_step1.sequence_contents &lt;&lt; content1\n\n# Simplified example - Adding content to the second email step (3 days later)\ncontent2 = Engage::SequenceStepContent.new(\n  stepable_type: \"Engage::EmailStep\",\n  stepable_attributes: {\n    subject: \"Checking in!\",\n    body: \"Hi {{FIRST_NAME}}, how are you finding our platform?\"\n  }\n)\nsequence_step2.sequence_contents &lt;&lt; content2\n</code></pre> <p>This code creates two <code>Engage::SequenceStepContent</code> objects.  <code>stepable_type</code> tells us this content is for an email step. <code>stepable_attributes</code> holds the actual email content: subject and body. Notice the <code>{{FIRST_NAME}}</code> placeholder, which will be replaced with the recipient's name when the email is sent.</p>"},{"location":"uui/06_engage_sequence_step_content/#under-the-hood","title":"Under the Hood","text":"<p>When a step in a sequence is executed:</p> <pre><code>sequenceDiagram\n    participant Engage Sequence\n    participant Sequence Step\n    participant Step Content\n    participant Go Engage\n    Engage Sequence-&gt;&gt;Sequence Step: Execute Step\n    Sequence Step-&gt;&gt;Step Content: Fetch Message Content\n    Step Content--&gt;&gt;Sequence Step: Email Subject &amp; Body with Placeholders\n    Sequence Step-&gt;&gt;Go Engage: Send Personalized Email\n    Go Engage--&gt;&gt;Sequence Step: Confirmation\n</code></pre> <ol> <li>Execute Step:  The sequence executes the current step.</li> <li>Fetch Message Content: The step retrieves the message template from the associated Step Content.</li> <li>Send Personalized Email:  The placeholders in the template are replaced with the contact's data, and the personalized email is sent via Go Engage.</li> </ol>"},{"location":"uui/06_engage_sequence_step_content/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceStepContent</code> model (app/models/engage/sequence_step_content.rb) is responsible for storing and managing step content.</p> <pre><code># app/models/engage/sequence_step_content.rb (simplified)\nclass Engage::SequenceStepContent &lt; ApplicationRecord\n  belongs_to :stepable, polymorphic: true # Connects to the specific content type (e.g., EmailStep)\n  belongs_to :sequence_step # Connects to the parent step\n  # ... other code ...\nend\n</code></pre> <p>The <code>belongs_to :stepable</code> relationship allows different types of content (email, SMS, etc.) to be associated with a step. The <code>belongs_to :sequence_step</code> connects the content to its parent step.</p>"},{"location":"uui/06_engage_sequence_step_content/#conclusion","title":"Conclusion","text":"<p>This chapter covered Engage Sequence Step Content, which holds the actual message templates for your sequence steps. You learned how to create and associate content with email steps, using placeholders for personalization.  Next, we'll look at how contacts are enrolled in sequences with Engage Sequence Membership.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/07_engage_sequence_membership/","title":"Chapter 7: Engage Sequence Membership","text":"<p>Continuing from our discussion on Engage Sequence Step Content, let's learn how to actually enroll contacts in our sequences: using Engage Sequence Membership.</p> <p>Imagine you've created a fantastic automated email sequence to welcome new leads.  You have your emails ready (Engage Sequence Step Content) and the timing defined (Engage Sequence Step). But how do you get people into this sequence? That's precisely what Engage Sequence Membership handles. It's like giving someone a ticket to your automated email show.</p>"},{"location":"uui/07_engage_sequence_membership/#key-concepts","title":"Key Concepts","text":"<ul> <li>Connection: An Engage Sequence Membership links a contact (GoAI Campaign's Target Audience) to a specific Engage Sequence.  It's like assigning a seat to a ticket holder.</li> <li>Progress Tracking: It keeps track of the contact's journey through the sequence. Which emails have they received? Have they opened or clicked any links? It's like a program for your email show, marking where each attendee is.</li> <li>Status:  It records the contact's current status in the sequence: are they actively receiving messages, paused, or finished? Think of it as updating the attendee's status:  \"currently watching,\" \"intermission,\" or \"show over.\"</li> </ul>"},{"location":"uui/07_engage_sequence_membership/#enrolling-a-contact","title":"Enrolling a Contact","text":"<p>Let's enroll a contact named Alice into our \"New Lead Welcome Sequence\":</p> <pre><code># Simplified example - Enrolling a contact (app_user) in a sequence\nalice = AppUser.find_by(first_name: \"Alice\") # Find Alice in our database\nsequence = Engage::Sequence.find_by(name: \"New Lead Welcome Sequence\") # Find the sequence\n\nmembership = Engage::SequenceMembership.create(app_user: alice, sequence: sequence)\n</code></pre> <p>This creates a new <code>Engage::SequenceMembership</code> that connects Alice (<code>app_user</code>) to the \"New Lead Welcome Sequence\" (<code>sequence</code>). Now Alice is enrolled and will start receiving the emails according to the sequence's steps.</p>"},{"location":"uui/07_engage_sequence_membership/#under-the-hood","title":"Under the Hood","text":"<p>When a new <code>Engage::SequenceMembership</code> is created:</p> <pre><code>sequenceDiagram\n    participant User\n    participant App\n    participant SequenceMembership\n    participant Sequence\n    participant Go Engage\n    User-&gt;&gt;App: Enroll Contact in Sequence\n    App-&gt;&gt;SequenceMembership: Create Membership\n    SequenceMembership-&gt;&gt;Sequence: Activate Sequence for Contact\n    Sequence-&gt;&gt;Go Engage: Start Sending Messages\n</code></pre> <ol> <li>Create Membership:  A new <code>Engage::SequenceMembership</code> is created, linking the contact and the sequence.</li> <li>Activate Sequence: The sequence becomes active for this contact.</li> <li>Start Sending:  Go Engage begins sending the messages according to the sequence's steps.</li> </ol>"},{"location":"uui/07_engage_sequence_membership/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceMembership</code> model (app/models/engage/sequence_membership.rb) manages the relationship between contacts and sequences.</p> <pre><code># app/models/engage/sequence_membership.rb (simplified)\nclass Engage::SequenceMembership &lt; ApplicationRecord\n  belongs_to :app_user # Connects to the contact\n  belongs_to :sequence, class_name: \"Engage::Sequence\" # Connects to the sequence\n  # ... other code for tracking progress, status, etc. ...\nend\n</code></pre> <p>The <code>belongs_to :app_user</code> and <code>belongs_to :sequence</code> lines establish the crucial connections. Other attributes and methods in this model handle tracking the contact's progress, status, and interactions within the sequence.</p>"},{"location":"uui/07_engage_sequence_membership/#conclusion","title":"Conclusion","text":"<p>In this chapter, we explored Engage Sequence Membership, which is the key to enrolling contacts in your automated sequences. You learned how to create a membership and saw how it works behind the scenes. In the next chapter, we'll explore how to track specific interactions within a sequence using Engage Sequence Event.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/07_translations/","title":"Chapter 7: Translations","text":"<p>In the previous chapter on Customization, we learned how to visually tailor the Messenger to reflect your brand.  Now, let's explore how to make it speak your users' language\u2014literally!  <code>Translations</code> in <code>uui</code> allow you to offer your Messenger experience in multiple languages, expanding your reach and making your users feel at home.</p> <p>Imagine you have customers from all over the world. Wouldn't it be great if they could interact with your Messenger in their native language?  Translations make this possible!</p>"},{"location":"uui/07_translations/#making-your-messenger-multilingual","title":"Making Your Messenger Multilingual","text":"<p>Let's say you want to offer your Messenger in both English and Spanish.  This is like having staff who can speak both languages.</p> <p>The core of translations in <code>uui</code> relies on YAML files containing key-value pairs.  The keys represent the original text, and the values are the translated text.</p> <pre><code># config/locales/en.yml (English)\nen:\n  start_conversation: \"Start a conversation\"\n  hello: \"Hello\"\n\n# config/locales/es.yml (Spanish)\nes:\n  start_conversation: \"Inicia una conversaci\u00f3n\"\n  hello: \"Hola\"\n</code></pre> <p>These files define the translations for the keys \"start_conversation\" and \"hello\" in English and Spanish respectively.</p>"},{"location":"uui/07_translations/#using-translations-in-your-code","title":"Using Translations in your Code","text":"<p>To use these translations in your application, you use the <code>I18n</code> object, which is initialized with the translation data.  Think of the <code>I18n</code> object as a universal translator.</p> <p><pre><code>// app/javascript/locales.js (simplified)\nimport { I18n } from 'i18n-js';\nimport translations from './src/locales/translations.json'; // Compiled translations\n\nconst i18n = new I18n(translations);\ni18n.locale = document.documentElement.lang || 'en'; // Set the locale\nwindow.I18n = i18n; // Make I18n globally available\n</code></pre> This code imports the <code>I18n</code> library, loads the compiled translation data from <code>translations.json</code>, sets the locale based on the user's browser language, and makes the <code>I18n</code> object globally available.</p> <p>Now, you can use the <code>t</code> function (provided by <code>I18n</code>) to translate text in your components:</p> <pre><code>// Example usage in a React component\n// ...other code\n\n&lt;button&gt;{I18n.t(\"start_conversation\")}&lt;/button&gt;\n\n// ...other code\n</code></pre> <p>This code snippet will render a button that displays \"Start a conversation\" if the locale is English, and \"Inicia una conversaci\u00f3n\" if the locale is Spanish.</p>"},{"location":"uui/07_translations/#under-the-hood","title":"Under the Hood","text":"<p>When the user opens the Messenger, the Javascript code detects the user's browser language or uses a default language.  Then, it uses the <code>I18n</code> object to retrieve the appropriate translations.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Messenger\n    participant I18n\n\n    User-&gt;&gt;Browser: Opens the Messenger\n    Browser-&gt;&gt;Messenger: Sends language preference\n    Messenger-&gt;&gt;I18n: Requests translation for \"start_conversation\"\n    I18n--&gt;&gt;Messenger: Returns translated text (\"Start a conversation\" or \"Inicia una conversaci\u00f3n\")\n    Messenger-&gt;&gt;Browser: Displays the translated text\n    Browser-&gt;&gt;User: Sees the translated button\n</code></pre> <p>The <code>I18n</code> object looks up the key in the loaded translation data and returns the corresponding translated text based on the current locale.</p>"},{"location":"uui/07_translations/#managing-translations-with-crowdin","title":"Managing Translations with Crowdin","text":"<p><code>uui</code> uses Crowdin, a localization management platform, to manage translations efficiently. Crowdin simplifies the process of translating your app into multiple languages.</p> <p>The <code>crowdin.yml</code> file configures which files should be synchronized with Crowdin for translation.  </p> <pre><code># crowdin.yml (simplified)\nfiles:\n  - source: /config/locales/en.yml\n    translation: /config/locales/%two_letters_code%.yml\n</code></pre> <p>This configuration tells Crowdin to use <code>en.yml</code> as the source language file and generate translation files like <code>es.yml</code>, <code>fr.yml</code>, etc. based on the two-letter language codes.</p>"},{"location":"uui/07_translations/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about <code>Translations</code> and how they enable a multilingual Messenger experience. We explored how to define translations in YAML files, use the <code>I18n</code> object to translate text in our components, and how Crowdin streamlines the translation management process. Now you can create a more inclusive and personalized experience for your users worldwide. In the next chapter, we will explore Stimulus Controllers and how they enhance interactivity in your <code>uui</code> application.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/08_engage_sequence_event/","title":"Chapter 8: Engage Sequence Event","text":"<p>Continuing from our discussion on Engage Sequence Membership, let's explore how to track the interactions within a sequence: Engage Sequence Events.</p> <p>Imagine you're running a marathon.  You know who's participating (Engage Sequence Membership), but you also want to track their progress: when they reach certain checkpoints, their pace, or if they stop for a water break.  Engage Sequence Events are like those checkpoints, recording every interaction a contact has within a sequence.</p>"},{"location":"uui/08_engage_sequence_event/#key-concepts","title":"Key Concepts","text":"<ul> <li>Timestamp: Each event has a timestamp, showing when it happened. Think of it as the time recorded at each checkpoint in the marathon.</li> <li>Event Type: This specifies what happened: an email open, a link click, a reply, a bounce, etc.  It's like noting whether the runner grabbed water or just passed the checkpoint.</li> <li>Data:  This provides additional details about the event, like which link was clicked or the content of a reply. It's like recording the runner's pace at a specific checkpoint.</li> </ul>"},{"location":"uui/08_engage_sequence_event/#tracking-an-email-open","title":"Tracking an Email Open","text":"<p>Let's say Alice, who is enrolled in our \"New Lead Welcome Sequence,\" opens the first welcome email.  This action triggers an Engage Sequence Event:</p> <pre><code># Simplified example - Logging an email open event\nevent = Engage::SequenceEvent.create!(\n  event_type: \"opened\", \n  occurred_at: Time.current,\n  sequence_membership: membership, # Alice's membership\n  sequence_step: step # The step that sent the email\n)\n</code></pre> <p>This creates an <code>Engage::SequenceEvent</code> record. <code>event_type: \"opened\"</code> specifies the type of event. <code>occurred_at</code> records the timestamp. The event is linked to Alice's <code>membership</code> and the specific <code>step</code> that triggered it.</p>"},{"location":"uui/08_engage_sequence_event/#under-the-hood","title":"Under the Hood","text":"<p>When a contact interacts with a sequence, here's how an event is logged:</p> <pre><code>sequenceDiagram\n    participant Contact\n    participant Go Engage\n    participant App\n    participant Sequence Event\n    Contact-&gt;&gt;Go Engage: Opens Email\n    Go Engage-&gt;&gt;App: Email Opened Notification\n    App-&gt;&gt;Sequence Event: Create \"opened\" Event\n</code></pre> <ol> <li>Interaction: The contact interacts with the sequence (e.g., opens an email).</li> <li>Notification: Go Engage notifies the application about the interaction.</li> <li>Create Event: The application creates an <code>Engage::SequenceEvent</code> record.</li> </ol>"},{"location":"uui/08_engage_sequence_event/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceEvent</code> model (app/models/engage/sequence_event.rb) stores and manages these events.</p> <pre><code># app/models/engage/sequence_event.rb (simplified)\nclass Engage::SequenceEvent &lt; ApplicationRecord\n  belongs_to :sequence_membership # Connects to the membership\n  belongs_to :sequence_step # Connects to the step\n  # ... other code ...\nend\n</code></pre> <p>The <code>belongs_to :sequence_membership</code> and <code>belongs_to :sequence_step</code> relationships link the event to the relevant membership and step. The <code>event_type</code> and <code>occurred_at</code> attributes store the event's key information. The <code>data</code> attribute can hold additional details as needed.</p>"},{"location":"uui/08_engage_sequence_event/#conclusion","title":"Conclusion","text":"<p>This chapter introduced Engage Sequence Events, essential for tracking contact interactions within your automated sequences. You learned how to create events and how they are logged behind the scenes.  Next, we'll explore how to manage credentials for sending messages with Engage Sequence OAuth Credential.</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/08_stimulus_controllers/","title":"Chapter 8: Stimulus Controllers","text":"<p>Following our discussion on Translations, let's dive into a key part of <code>uui</code>'s interactivity: <code>Stimulus Controllers</code>.  Imagine you want a button in your Messenger that, when clicked, reveals extra options.  Stimulus Controllers are like the tiny computers behind such interactive elements. They connect your HTML to JavaScript, enabling dynamic behavior in response to user actions.</p>"},{"location":"uui/08_stimulus_controllers/#making-your-messenger-more-dynamic","title":"Making Your Messenger More Dynamic","text":"<p>Let's say you want to show a welcome message when the Messenger first opens, then hide it when the user clicks a \"Close\" button. This is a perfect use case for a Stimulus Controller.</p>"},{"location":"uui/08_stimulus_controllers/#building-a-simple-controller","title":"Building a Simple Controller","text":"<p>First, let's create a Stimulus Controller to manage this behavior.  Think of it as the small computer controlling our welcome message.</p> <pre><code>// app/javascript/controllers/welcome_controller.js\nimport { Controller } from \"@hotwired/stimulus\"\n\nexport default class extends Controller {\n  connect() {\n    // This code runs when the controller is connected\n    console.log(\"Welcome controller connected!\");\n  }\n\n  hideWelcome() {\n    this.element.style.display = \"none\";\n  }\n}\n</code></pre> <p>This code defines a controller named <code>welcome_controller</code>.  The <code>connect()</code> function is called when the controller is connected to the HTML element.  The <code>hideWelcome()</code> function will hide the element it's attached to.</p>"},{"location":"uui/08_stimulus_controllers/#connecting-the-controller-to-html","title":"Connecting the Controller to HTML","text":"<p>Now, let's connect this controller to our welcome message in the HTML. This is like wiring the computer to the message display.</p> <pre><code>&lt;div data-controller=\"welcome\"&gt;\n  &lt;p&gt;Welcome to our chat!&lt;/p&gt;\n  &lt;button data-action=\"click-&gt;welcome#hideWelcome\"&gt;Close&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>data-controller=\"welcome\"</code> attribute connects the <code>div</code> to our <code>welcome_controller</code>. The <code>data-action=\"click-&gt;welcome#hideWelcome\"</code> attribute tells Stimulus to call the <code>hideWelcome()</code> function when the button is clicked.  <code>click</code> refers to the event and <code>welcome#hideWelcome</code> identifies the controller and method to call.</p>"},{"location":"uui/08_stimulus_controllers/#under-the-hood","title":"Under the Hood","text":"<p>When the page loads, Stimulus scans the HTML for <code>data-controller</code> attributes. It then creates an instance of the corresponding controller and connects it to the element. When the button is clicked, Stimulus handles the event and calls the specified controller method.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant Stimulus\n    participant welcome_controller\n\n    User-&gt;&gt;Browser: Clicks the \"Close\" button\n    Browser-&gt;&gt;Stimulus: Triggers the \"click\" event\n    Stimulus-&gt;&gt;welcome_controller: Calls hideWelcome()\n    welcome_controller-&gt;&gt;Browser: Hides the welcome message\n    Browser-&gt;&gt;User: The welcome message disappears\n</code></pre> <p>Stimulus acts as the intermediary, handling the event and delegating the action to the correct controller.  The <code>index.js</code> file is responsible for loading all controllers:</p> <pre><code>// app/javascript/controllers/index.js (simplified)\n// ... other code ...\nimport controllers from './**/*_controller.js';\n\ncontrollers.forEach((controller) =&gt; {\n  application.register(controller.name, controller.module.default);\n});\n</code></pre> <p>This code imports all controllers and registers them with the Stimulus application.</p>"},{"location":"uui/08_stimulus_controllers/#conclusion","title":"Conclusion","text":"<p>In this chapter, we learned about Stimulus Controllers and how they enhance interactivity in <code>uui</code>.  We built a simple controller to show and hide a welcome message and saw how to connect it to our HTML. This provides a fundamental understanding of how Stimulus brings dynamic behavior to your frontend.  While there's no specific next chapter in this tutorial, exploring the <code>uui</code> codebase further will reveal more advanced uses of Stimulus Controllers, such as managing AppPackages, handling events in the Messenger, and controlling the flow of Bot Tasks.  Keep experimenting and building!</p> <p>Generated by AI Codebase Knowledge Builder</p>"},{"location":"uui/09_engage_sequence_oauth_credential/","title":"Chapter 9: Engage Sequence OAuth Credential","text":"<p>Continuing from our discussion on Engage Sequence Events, let's explore how to manage credentials for sending messages: Engage Sequence OAuth Credentials.</p> <p>Imagine you have multiple team members sending emails as part of your automated sequences. Each team member needs their own email account access so they don't all send from the same address.  Engage Sequence OAuth Credentials manage these access \"keys\" for each sequence.  They're like keychains holding keys to different mailboxes, ensuring emails are sent from the right accounts and managing sending limits.</p>"},{"location":"uui/09_engage_sequence_oauth_credential/#key-concepts","title":"Key Concepts","text":"<ul> <li>OAuth Credential:  This is the \"key\" itself, granting access to a specific email account (or other communication channels).  Think of this as a single key on your keychain.</li> <li>Connection to Sequence:  An Engage Sequence can have multiple OAuth Credentials associated with it, like having multiple keys on a keychain for different mailboxes. This allows a sequence to send emails from different accounts.</li> <li>Managing Sending Limits: The system uses these credentials to track and respect daily sending limits for each connected email account, preventing accounts from being flagged as spam.  This is like knowing the daily usage limit for each mailbox.</li> </ul>"},{"location":"uui/09_engage_sequence_oauth_credential/#sending-emails-from-multiple-accounts","title":"Sending Emails from Multiple Accounts","text":"<p>Let's say our \"New Lead Welcome Sequence\" needs to send emails from two different accounts: <code>sales@example.com</code> and <code>marketing@example.com</code>.</p> <ol> <li> <p>Create OAuth Credentials: First, you create OAuth Credentials for each email account. Let's assume these credentials are stored in our database as <code>OauthCredential</code> objects and we have two: <code>sales_credential</code> and <code>marketing_credential</code>.</p> </li> <li> <p>Connect Credentials to Sequence:  We connect these credentials to our sequence:</p> <pre><code># Simplified example - Connecting credentials to a sequence\nsequence = Engage::Sequence.find_by(name: \"New Lead Welcome Sequence\")\nsequence.oauth_credentials &lt;&lt; sales_credential\nsequence.oauth_credentials &lt;&lt; marketing_credential\n</code></pre> </li> </ol> <p>This code adds both <code>sales_credential</code> and <code>marketing_credential</code> to the <code>sequence</code>. Now, the sequence can use either of these credentials when sending emails.</p>"},{"location":"uui/09_engage_sequence_oauth_credential/#under-the-hood","title":"Under the Hood","text":"<p>When a sequence needs to send an email:</p> <pre><code>sequenceDiagram\n    participant Sequence\n    participant OAuth Credentials\n    participant Credential Selector\n    participant Go Engage\n    Sequence-&gt;&gt;Credential Selector: Request Credential\n    Credential Selector-&gt;&gt;OAuth Credentials: Find Available Credential\n    OAuth Credentials--&gt;&gt;Credential Selector: sales@example.com Credential\n    Credential Selector--&gt;&gt;Sequence: sales@example.com Credential\n    Sequence-&gt;&gt;Go Engage: Send Email using Credential\n</code></pre> <ol> <li>Request Credential: The sequence requests an available credential.</li> <li>Find Available Credential: The system checks which credentials are associated with the sequence and selects one that's below its daily sending limit and hasn't been used recently.</li> <li>Send Email: The sequence uses the selected credential to send the email via Go Engage.</li> </ol>"},{"location":"uui/09_engage_sequence_oauth_credential/#diving-deeper-into-the-code","title":"Diving Deeper into the Code","text":"<p>The <code>Engage::SequenceOauthCredential</code> model (app/models/engage/sequence_oauth_credential.rb) manages the association between sequences and credentials.</p> <pre><code># app/models/engage/sequence_oauth_credential.rb (simplified)\nclass Engage::SequenceOauthCredential &lt; ApplicationRecord\n  belongs_to :sequence # Connects to the sequence\n  belongs_to :oauth_credential # Connects to the credential\nend\n</code></pre> <p>The <code>Engage::Sequence</code> model also has a relationship with <code>OauthCredential</code>:</p> <pre><code># app/models/engage/sequence.rb (simplified)\nclass Engage::Sequence &lt; ApplicationRecord\n  has_many :oauth_credentials, through: :sequence_oauth_credentials\n  # ... other code ...\n\n  def next_available_credential\n    sequence_oauth_credentials.available_for_sending.last_used_random.first&amp;.oauth_credential\n  end\nend\n</code></pre> <p>The <code>next_available_credential</code> method finds a credential that's available for sending based on its usage and daily limits.  The <code>available_for_sending</code> scope handles checking these conditions.</p>"},{"location":"uui/09_engage_sequence_oauth_credential/#conclusion","title":"Conclusion","text":"<p>This chapter explained how Engage Sequence OAuth Credentials manage access to email accounts for your sequences, allowing you to send from multiple addresses and manage sending limits.  You learned how to connect credentials to your sequences and saw how the system selects an available credential for sending. This concludes our series on the core components of the <code>uui</code> project. You should now have a good understanding of how to build and manage automated communication sequences.</p> <p>Generated by AI Codebase Knowledge Builder</p>"}]}